/**
 * @license Angular l10n
 * Copyright Roberto Simonetti
 * MIT license
 * https://github.com/robisim74/angular-l10n
 */

import { ChangeDetectorRef, Directive, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Injector, Input, NgModule, Output, Pipe, Renderer2, forwardRef } from '@angular/core';
import { __assign, __awaiter, __extends, __generator } from 'tslib';
import { Subject as Subject$1 } from 'rxjs/Subject';
import { Observable as Observable$1 } from 'rxjs/Observable';
import { BehaviorSubject as BehaviorSubject$1 } from 'rxjs/BehaviorSubject';
import { merge as merge$1 } from 'rxjs/observable/merge';
import { concat as concat$1 } from 'rxjs/observable/concat';
import { HttpClient } from '@angular/common/http';
import { ReplaySubject as ReplaySubject$1 } from 'rxjs/ReplaySubject';
import { NG_VALIDATORS } from '@angular/forms';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Allows to get the dependencies at the module level or component.
 */
var InjectorRef = (function () {
    function InjectorRef(injector) {
        this.injector = injector;
        InjectorRef.injector = this.injector;
    }
    /**
     * @template T
     * @param {?} token
     * @return {?}
     */
    InjectorRef.get = /**
     * @template T
     * @param {?} token
     * @return {?}
     */
    function (token) {
        return InjectorRef.injector.get(token);
    };
    InjectorRef.injector = null;
    InjectorRef.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    InjectorRef.ctorParameters = function () { return [
        { type: Injector, },
    ]; };
    return InjectorRef;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @record
 */

/**
 * @record
 */

/**
 * @record
 */

/**
 * @record
 */

/** @enum {number} */
var StorageStrategy = {
    Session: 0,
    Local: 1,
    Cookie: 2,
    Disabled: 3,
};
StorageStrategy[StorageStrategy.Session] = "Session";
StorageStrategy[StorageStrategy.Local] = "Local";
StorageStrategy[StorageStrategy.Cookie] = "Cookie";
StorageStrategy[StorageStrategy.Disabled] = "Disabled";
/** @enum {number} */
var ProviderType = {
    Fallback: 0,
    Static: 1,
    WebAPI: 2,
};
ProviderType[ProviderType.Fallback] = "Fallback";
ProviderType[ProviderType.Static] = "Static";
ProviderType[ProviderType.WebAPI] = "WebAPI";
/** @enum {number} */
var ISOCode = {
    Language: 0,
    Country: 1,
    Script: 2,
};
ISOCode[ISOCode.Language] = "Language";
ISOCode[ISOCode.Country] = "Country";
ISOCode[ISOCode.Script] = "Script";
/** @enum {number} */
var LoadingMode = {
    Direct: 0,
    Async: 1,
};
LoadingMode[LoadingMode.Direct] = "Direct";
LoadingMode[LoadingMode.Async] = "Async";
/** @enum {number} */
var ServiceState = {
    isReady: 0,
    isLoading: 1,
    isWaiting: 2,
};
ServiceState[ServiceState.isReady] = "isReady";
ServiceState[ServiceState.isLoading] = "isLoading";
ServiceState[ServiceState.isWaiting] = "isWaiting";
/** @enum {number} */
var NumberFormatStyle = {
    Decimal: 0,
    Percent: 1,
    Currency: 2,
};
NumberFormatStyle[NumberFormatStyle.Decimal] = "Decimal";
NumberFormatStyle[NumberFormatStyle.Percent] = "Percent";
NumberFormatStyle[NumberFormatStyle.Currency] = "Currency";

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var LOCALE_CONFIG = new InjectionToken('LOCALE_CONFIG');
var TRANSLATION_CONFIG = new InjectionToken('TRANSLATION_CONFIG');
/**
 * @record
 */

/**
 * @record
 */

/**
 * @record
 */

/**
 * @record
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Provides the methods to check if Intl APIs are supported.
 */
var IntlAPI = (function () {
    function IntlAPI() {
    }
    /**
     * @return {?}
     */
    IntlAPI.hasIntl = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ hasIntl = typeof Intl === "object" && !!Intl;
        return hasIntl;
    };
    /**
     * @return {?}
     */
    IntlAPI.hasDateTimeFormat = /**
     * @return {?}
     */
    function () {
        return IntlAPI.hasIntl() && Intl.hasOwnProperty("DateTimeFormat");
    };
    /**
     * @return {?}
     */
    IntlAPI.hasTimezone = /**
     * @return {?}
     */
    function () {
        if (IntlAPI.hasIntl() && IntlAPI.hasDateTimeFormat()) {
            try {
                new Intl.DateTimeFormat('en-US', { timeZone: 'America/Los_Angeles' }).format(new Date());
            }
            catch (/** @type {?} */ e) {
                return false;
            }
            return true;
        }
        return false;
    };
    /**
     * @return {?}
     */
    IntlAPI.hasNumberFormat = /**
     * @return {?}
     */
    function () {
        return IntlAPI.hasIntl() && Intl.hasOwnProperty("NumberFormat");
    };
    /**
     * @return {?}
     */
    IntlAPI.hasCollator = /**
     * @return {?}
     */
    function () {
        return IntlAPI.hasIntl() && Intl.hasOwnProperty("Collator");
    };
    return IntlAPI;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Implement this class-interface to create a custom storage for default locale, currency & timezone.
 * @abstract
 */
var LocaleStorage = (function () {
    function LocaleStorage() {
    }
    LocaleStorage.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    LocaleStorage.ctorParameters = function () { return []; };
    return LocaleStorage;
}());
var BrowserStorage = (function () {
    function BrowserStorage(configuration) {
        this.configuration = configuration;
        this.hasCookie = typeof navigator !== "undefined" && navigator.cookieEnabled;
        this.hasStorage = typeof Storage !== "undefined";
    }
    /**
     * @param {?} name
     * @return {?}
     */
    BrowserStorage.prototype.read = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        return __awaiter(this, void 0, void 0, function () {
            var value;
            return __generator(this, function (_a) {
                value = null;
                if (this.configuration.storage != StorageStrategy.Disabled) {
                    if (this.configuration.storage == StorageStrategy.Local && this.hasStorage) {
                        value = this.getLocalStorage(name);
                    }
                    else if (this.configuration.storage == StorageStrategy.Session && this.hasStorage) {
                        value = this.getSessionStorage(name);
                    }
                    else if (this.configuration.storage == StorageStrategy.Cookie && this.hasCookie) {
                        value = this.getCookie(name);
                    }
                }
                return [2 /*return*/, value];
            });
        });
    };
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    BrowserStorage.prototype.write = /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (name, value) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.configuration.storage != StorageStrategy.Disabled) {
                    if (this.configuration.storage == StorageStrategy.Local && this.hasStorage) {
                        this.setLocalStorage(name, value);
                    }
                    else if (this.configuration.storage == StorageStrategy.Session && this.hasStorage) {
                        this.setSessionStorage(name, value);
                    }
                    else if (this.configuration.storage == StorageStrategy.Cookie && this.hasCookie) {
                        this.setCookie(name, value);
                    }
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * @param {?} name
     * @return {?}
     */
    BrowserStorage.prototype.getLocalStorage = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        return localStorage.getItem(name);
    };
    /**
     * @param {?} name
     * @return {?}
     */
    BrowserStorage.prototype.getSessionStorage = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        return sessionStorage.getItem(name);
    };
    /**
     * @param {?} name
     * @return {?}
     */
    BrowserStorage.prototype.getCookie = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        var /** @type {?} */ result = null;
        if (typeof document !== "undefined") {
            result = new RegExp("(?:^|; )" + encodeURIComponent(name) + "=([^;]*)").exec(document.cookie);
        }
        return result ? result[1] : null;
    };
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    BrowserStorage.prototype.setLocalStorage = /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (name, value) {
        localStorage.setItem(name, value);
    };
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    BrowserStorage.prototype.setSessionStorage = /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (name, value) {
        sessionStorage.setItem(name, value);
    };
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    BrowserStorage.prototype.setCookie = /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (name, value) {
        var /** @type {?} */ expires = "";
        if (this.configuration.cookieExpiration != null) {
            var /** @type {?} */ expirationDate = new Date();
            expirationDate.setTime(expirationDate.getTime() +
                (this.configuration.cookieExpiration * 24 * 60 * 60 * 1000));
            expires = "; expires=" + expirationDate.toUTCString();
        }
        if (typeof document !== "undefined") {
            document.cookie = name + "=" + value + expires + "; path=/";
        }
    };
    BrowserStorage.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    BrowserStorage.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [LOCALE_CONFIG,] },] },
    ]; };
    return BrowserStorage;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DefaultLocale = (function () {
    function DefaultLocale() {
    }
    Object.defineProperty(DefaultLocale.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this._value;
        },
        set: /**
         * @param {?} defaultLocale
         * @return {?}
         */
        function (defaultLocale) {
            this._value = defaultLocale;
            this.parseValue();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} languageCode
     * @param {?=} countryCode
     * @param {?=} scriptCode
     * @param {?=} numberingSystem
     * @param {?=} calendar
     * @return {?}
     */
    DefaultLocale.prototype.build = /**
     * @param {?} languageCode
     * @param {?=} countryCode
     * @param {?=} scriptCode
     * @param {?=} numberingSystem
     * @param {?=} calendar
     * @return {?}
     */
    function (languageCode, countryCode, scriptCode, numberingSystem, calendar) {
        this.languageCode = languageCode;
        this.scriptCode = scriptCode;
        this.countryCode = countryCode;
        this.numberingSystem = numberingSystem;
        this.calendar = calendar;
        var /** @type {?} */ value = [];
        value.push(languageCode);
        value.push(!!scriptCode ? "-" + scriptCode : "");
        value.push(!!countryCode ? "-" + countryCode : "");
        // Adds the 'u' (Unicode) extension.
        value.push((!!numberingSystem || !!calendar) ? "-u" : "");
        value.push(!!numberingSystem ? "-nu-" + numberingSystem : "");
        value.push(!!calendar ? "-ca-" + calendar : "");
        this._value = value.join("");
    };
    /**
     * @return {?}
     */
    DefaultLocale.prototype.parseValue = /**
     * @return {?}
     */
    function () {
        if (!!this.value) {
            var /** @type {?} */ value = this.value;
            // Looks for the 'u' (Unicode) extension.
            var /** @type {?} */ index = value.search("-u");
            if (index != -1) {
                var /** @type {?} */ extensions = value.substring(index + 1).split("-");
                switch (extensions.length) {
                    case 3:
                        if (extensions[1] == "nu") {
                            this.numberingSystem = extensions[2];
                        }
                        else if (extensions[1] == "ca") {
                            this.calendar = extensions[2];
                        }
                        break;
                    default:
                        this.numberingSystem = extensions[2];
                        this.calendar = extensions[4];
                        break;
                }
                // Extracts the codes.
                value = value.substring(0, index);
            }
            var /** @type {?} */ codes = value.split("-");
            switch (codes.length) {
                case 1:
                    this.languageCode = codes[0];
                    break;
                case 2:
                    this.languageCode = codes[0];
                    this.countryCode = codes[1];
                    break;
                default:
                    this.languageCode = codes[0];
                    this.scriptCode = codes[1];
                    this.countryCode = codes[2];
                    break;
            }
        }
    };
    return DefaultLocale;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Manages language, default locale, currency & timezone.
 * @record
 */

/**
 * Manages language, default locale, currency & timezone.
 */
var LocaleService = (function () {
    function LocaleService(configuration, storage) {
        this.configuration = configuration;
        this.storage = storage;
        this.languageCodeChanged = new EventEmitter(true);
        this.defaultLocaleChanged = new EventEmitter(true);
        this.currencyCodeChanged = new EventEmitter(true);
        this.timezoneChanged = new EventEmitter(true);
        this.loadTranslation = new Subject$1();
        this.defaultLocale = new DefaultLocale();
    }
    /**
     * @return {?}
     */
    LocaleService.prototype.getConfiguration = /**
     * @return {?}
     */
    function () {
        return this.configuration;
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.init = /**
     * @return {?}
     */
    function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.initStorage()];
                    case 1:
                        _a.sent();
                        if (this.configuration.defaultLocale) {
                            this.initDefaultLocale();
                        }
                        else if (this.configuration.language) {
                            this.initLanguage();
                        }
                        if (this.configuration.currency) {
                            this.initCurrency();
                        }
                        if (this.configuration.timezone) {
                            this.initTimezone();
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.getBrowserLanguage = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ browserLanguage = null;
        if (typeof navigator !== "undefined" && navigator.language) {
            browserLanguage = navigator.language;
        }
        if (browserLanguage != null) {
            var /** @type {?} */ index = browserLanguage.indexOf("-");
            if (index != -1) {
                browserLanguage = browserLanguage.substring(0, index);
            }
        }
        return browserLanguage;
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.getAvailableLanguages = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ languages = [];
        if (this.configuration.languages) {
            languages = this.configuration.languages.map(function (language) { return language.code; });
        }
        return languages;
    };
    /**
     * @param {?=} languageCode
     * @return {?}
     */
    LocaleService.prototype.getLanguageDirection = /**
     * @param {?=} languageCode
     * @return {?}
     */
    function (languageCode) {
        if (languageCode === void 0) { languageCode = this.defaultLocale.languageCode; }
        var /** @type {?} */ matchedLanguages = this.matchLanguage(languageCode);
        return matchedLanguages[0].dir;
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.getCurrentLanguage = /**
     * @return {?}
     */
    function () {
        return this.defaultLocale.languageCode;
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.getCurrentCountry = /**
     * @return {?}
     */
    function () {
        if (!!this.defaultLocale.countryCode) {
            return this.defaultLocale.countryCode;
        }
        return "";
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.getCurrentScript = /**
     * @return {?}
     */
    function () {
        if (!!this.defaultLocale.scriptCode) {
            return this.defaultLocale.scriptCode;
        }
        return "";
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.getCurrentLocale = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ locale = !!this.defaultLocale.countryCode
            ? this.defaultLocale.languageCode + "-" + this.defaultLocale.countryCode
            : this.defaultLocale.languageCode;
        return locale;
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.getCurrentNumberingSystem = /**
     * @return {?}
     */
    function () {
        if (!!this.defaultLocale.numberingSystem) {
            return this.defaultLocale.numberingSystem;
        }
        return "";
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.getCurrentCalendar = /**
     * @return {?}
     */
    function () {
        if (!!this.defaultLocale.calendar) {
            return this.defaultLocale.calendar;
        }
        return "";
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.getDefaultLocale = /**
     * @return {?}
     */
    function () {
        return this.defaultLocale.value;
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.getCurrentCurrency = /**
     * @return {?}
     */
    function () {
        return this.currencyCode;
    };
    /**
     * @param {?=} currencyDisplay
     * @param {?=} defaultLocale
     * @param {?=} currency
     * @return {?}
     */
    LocaleService.prototype.getCurrencySymbol = /**
     * @param {?=} currencyDisplay
     * @param {?=} defaultLocale
     * @param {?=} currency
     * @return {?}
     */
    function (currencyDisplay, defaultLocale, currency) {
        if (currencyDisplay === void 0) { currencyDisplay = 'symbol'; }
        if (defaultLocale === void 0) { defaultLocale = this.defaultLocale.value; }
        if (currency === void 0) { currency = this.currencyCode; }
        var /** @type {?} */ currencySymbol = this.currencyCode;
        if (IntlAPI.hasNumberFormat()) {
            var /** @type {?} */ localeZero = new Intl.NumberFormat(defaultLocale).format(0);
            var /** @type {?} */ value = 0; // Reference value.
            var /** @type {?} */ localeValue = new Intl.NumberFormat(defaultLocale, {
                style: 'currency',
                currency: currency,
                currencyDisplay: currencyDisplay,
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            }).format(value);
            currencySymbol = localeValue.replace(localeZero, "");
            currencySymbol = currencySymbol.trim();
        }
        return currencySymbol;
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.getCurrentTimezone = /**
     * @return {?}
     */
    function () {
        return this.timezone;
    };
    /**
     * @param {?} languageCode
     * @return {?}
     */
    LocaleService.prototype.setCurrentLanguage = /**
     * @param {?} languageCode
     * @return {?}
     */
    function (languageCode) {
        if (this.defaultLocale.languageCode != languageCode) {
            this.defaultLocale.build(languageCode);
            this.storage.write("defaultLocale", this.defaultLocale.value);
            this.sendLanguageEvents();
            this.sendTranslationEvents();
        }
    };
    /**
     * @param {?} languageCode
     * @param {?=} countryCode
     * @param {?=} scriptCode
     * @param {?=} numberingSystem
     * @param {?=} calendar
     * @return {?}
     */
    LocaleService.prototype.setDefaultLocale = /**
     * @param {?} languageCode
     * @param {?=} countryCode
     * @param {?=} scriptCode
     * @param {?=} numberingSystem
     * @param {?=} calendar
     * @return {?}
     */
    function (languageCode, countryCode, scriptCode, numberingSystem, calendar) {
        if (this.defaultLocale.languageCode != languageCode ||
            this.defaultLocale.countryCode != countryCode ||
            this.defaultLocale.scriptCode != scriptCode ||
            this.defaultLocale.numberingSystem != numberingSystem ||
            this.defaultLocale.calendar != calendar) {
            this.defaultLocale.build(languageCode, countryCode, scriptCode, numberingSystem, calendar);
            this.storage.write("defaultLocale", this.defaultLocale.value);
            this.sendDefaultLocaleEvents();
            this.sendTranslationEvents();
        }
    };
    /**
     * @param {?} currencyCode
     * @return {?}
     */
    LocaleService.prototype.setCurrentCurrency = /**
     * @param {?} currencyCode
     * @return {?}
     */
    function (currencyCode) {
        if (this.currencyCode != currencyCode) {
            this.currencyCode = currencyCode;
            this.storage.write("currency", this.currencyCode);
            this.sendCurrencyEvents();
        }
    };
    /**
     * @param {?} zoneName
     * @return {?}
     */
    LocaleService.prototype.setCurrentTimezone = /**
     * @param {?} zoneName
     * @return {?}
     */
    function (zoneName) {
        if (this.timezone != zoneName) {
            this.timezone = zoneName;
            this.storage.write("timezone", this.timezone);
            this.sendTimezoneEvents();
        }
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.initStorage = /**
     * @return {?}
     */
    function () {
        return __awaiter(this, void 0, void 0, function () {
            var defaultLocale, currencyCode, zoneName;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!this.defaultLocale.value) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.storage.read("defaultLocale")];
                    case 1:
                        defaultLocale = _a.sent();
                        if (!!defaultLocale) {
                            this.defaultLocale.value = defaultLocale;
                        }
                        _a.label = 2;
                    case 2:
                        if (!(this.currencyCode == null)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.storage.read("currency")];
                    case 3:
                        currencyCode = _a.sent();
                        if (!!currencyCode) {
                            this.currencyCode = currencyCode;
                        }
                        _a.label = 4;
                    case 4:
                        if (!(this.timezone == null)) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.storage.read("timezone")];
                    case 5:
                        zoneName = _a.sent();
                        if (!!zoneName) {
                            this.timezone = zoneName;
                        }
                        _a.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.initLanguage = /**
     * @return {?}
     */
    function () {
        if (!this.defaultLocale.languageCode) {
            var /** @type {?} */ browserLanguage = this.getBrowserLanguage();
            var /** @type {?} */ matchedLanguages = [];
            if (!!browserLanguage) {
                matchedLanguages = this.matchLanguage(browserLanguage);
            }
            if (!!browserLanguage && matchedLanguages.length > 0) {
                this.defaultLocale.build(browserLanguage);
            }
            else if (this.configuration.language) {
                this.defaultLocale.build(this.configuration.language);
            }
            this.storage.write("defaultLocale", this.defaultLocale.value);
        }
        this.sendLanguageEvents();
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.initDefaultLocale = /**
     * @return {?}
     */
    function () {
        if (!this.defaultLocale.value) {
            if (this.configuration.defaultLocale) {
                this.defaultLocale.build(this.configuration.defaultLocale.languageCode, this.configuration.defaultLocale.countryCode, this.configuration.defaultLocale.scriptCode, this.configuration.defaultLocale.numberingSystem, this.configuration.defaultLocale.calendar);
                this.storage.write("defaultLocale", this.defaultLocale.value);
            }
        }
        this.sendDefaultLocaleEvents();
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.initCurrency = /**
     * @return {?}
     */
    function () {
        if (this.currencyCode == null) {
            if (this.configuration.currency) {
                this.currencyCode = this.configuration.currency;
                this.storage.write("currency", this.currencyCode);
            }
        }
        this.sendCurrencyEvents();
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.initTimezone = /**
     * @return {?}
     */
    function () {
        if (this.timezone == null) {
            if (this.configuration.timezone) {
                this.timezone = this.configuration.timezone;
                this.storage.write("timezone", this.timezone);
            }
        }
        this.sendCurrencyEvents();
    };
    /**
     * @param {?} languageCode
     * @return {?}
     */
    LocaleService.prototype.matchLanguage = /**
     * @param {?} languageCode
     * @return {?}
     */
    function (languageCode) {
        var /** @type {?} */ matchedLanguages = [];
        if (this.configuration.languages) {
            matchedLanguages = this.configuration.languages.filter(function (language) {
                return language.code == languageCode;
            });
        }
        return matchedLanguages;
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.sendLanguageEvents = /**
     * @return {?}
     */
    function () {
        this.languageCodeChanged.emit(this.defaultLocale.languageCode);
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.sendDefaultLocaleEvents = /**
     * @return {?}
     */
    function () {
        this.defaultLocaleChanged.emit(this.defaultLocale.value);
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.sendCurrencyEvents = /**
     * @return {?}
     */
    function () {
        this.currencyCodeChanged.emit(this.currencyCode);
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.sendTimezoneEvents = /**
     * @return {?}
     */
    function () {
        this.timezoneChanged.emit(this.timezone);
    };
    /**
     * @return {?}
     */
    LocaleService.prototype.sendTranslationEvents = /**
     * @return {?}
     */
    function () {
        // This event is subscribed by TranslationService to load the translation data.
        this.loadTranslation.next();
    };
    LocaleService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    LocaleService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [LOCALE_CONFIG,] },] },
        { type: LocaleStorage, },
    ]; };
    LocaleService.propDecorators = {
        "languageCodeChanged": [{ type: Output },],
        "defaultLocaleChanged": [{ type: Output },],
        "currencyCodeChanged": [{ type: Output },],
        "timezoneChanged": [{ type: Output },],
    };
    return LocaleService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Implement this class-interface to create a custom provider for translation data.
 * @abstract
 */
var TranslationProvider = (function () {
    function TranslationProvider() {
    }
    TranslationProvider.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    TranslationProvider.ctorParameters = function () { return []; };
    return TranslationProvider;
}());
var HttpTranslationProvider = (function () {
    function HttpTranslationProvider(configuration, http$$1) {
        this.configuration = configuration;
        this.http = http$$1;
        this.cache = {};
    }
    /**
     * @param {?} language
     * @param {?} args
     * @return {?}
     */
    HttpTranslationProvider.prototype.getTranslation = /**
     * @param {?} language
     * @param {?} args
     * @return {?}
     */
    function (language, args) {
        var /** @type {?} */ url = "";
        switch (args.type) {
            case ProviderType.WebAPI:
                url += args.path + language;
                break;
            default:
                url += args.prefix + language + ".json";
        }
        if (this.configuration.caching) {
            return this.caching(url, this.http.get(url));
        }
        return this.http.get(url);
    };
    /**
     * @param {?} key
     * @param {?} request
     * @return {?}
     */
    HttpTranslationProvider.prototype.caching = /**
     * @param {?} key
     * @param {?} request
     * @return {?}
     */
    function (key, request) {
        if (this.cache[key]) {
            return this.cache[key];
        }
        var /** @type {?} */ buffer = new ReplaySubject$1(1);
        request.subscribe(function (value) { return buffer.next(value); }, function (error) { return buffer.error(error); }, function () { return buffer.complete(); });
        var /** @type {?} */ response = buffer.asObservable();
        this.cache[key] = response;
        return response;
    };
    HttpTranslationProvider.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    HttpTranslationProvider.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLATION_CONFIG,] },] },
        { type: HttpClient, },
    ]; };
    return HttpTranslationProvider;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Implement this class-interface to create a custom handler for translated values.
 * @abstract
 */
var TranslationHandler = (function () {
    function TranslationHandler() {
    }
    TranslationHandler.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    TranslationHandler.ctorParameters = function () { return []; };
    return TranslationHandler;
}());
var DefaultTranslationHandler = (function () {
    function DefaultTranslationHandler(configuration) {
        this.configuration = configuration;
    }
    /**
     * @param {?} path
     * @param {?} key
     * @param {?} value
     * @param {?} args
     * @param {?} lang
     * @return {?}
     */
    DefaultTranslationHandler.prototype.parseValue = /**
     * @param {?} path
     * @param {?} key
     * @param {?} value
     * @param {?} args
     * @param {?} lang
     * @return {?}
     */
    function (path, key, value, args, lang) {
        if (value == null) {
            return this.handleMissingValue(path);
        }
        else if (args) {
            return this.handleArgs(value, args);
        }
        return value;
    };
    /**
     * @param {?} path
     * @return {?}
     */
    DefaultTranslationHandler.prototype.handleMissingValue = /**
     * @param {?} path
     * @return {?}
     */
    function (path) {
        if (this.configuration.missingValue) {
            return typeof this.configuration.missingValue === "function"
                ? this.configuration.missingValue(path)
                : this.configuration.missingValue;
        }
        // The same path is returned.
        return path;
    };
    /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    DefaultTranslationHandler.prototype.handleArgs = /**
     * @param {?} value
     * @param {?} args
     * @return {?}
     */
    function (value, args) {
        var /** @type {?} */ TEMPLATE_REGEXP = /{{\s?([^{}\s]*)\s?}}/g;
        return value.replace(TEMPLATE_REGEXP, function (substring, parsedKey) {
            var /** @type {?} */ replacer = /** @type {?} */ (args[parsedKey]);
            return typeof replacer !== "undefined" ? replacer : substring;
        });
    };
    DefaultTranslationHandler.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    DefaultTranslationHandler.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLATION_CONFIG,] },] },
    ]; };
    return DefaultTranslationHandler;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} item
 * @return {?}
 */
function isObject(item) {
    return (typeof item === "object" && !Array.isArray(item));
}
/**
 * @param {?} target
 * @param {?} source
 * @return {?}
 */
function mergeDeep(target, source) {
    var /** @type {?} */ output = Object.assign({}, target);
    if (isObject(target) && isObject(source)) {
        Object.keys(source).forEach(function (key) {
            if (isObject(source[key])) {
                if (!(key in target)) {
                    Object.assign(output, (_a = {}, _a[key] = source[key], _a));
                }
                else {
                    output[key] = mergeDeep(target[key], source[key]);
                }
            }
            else {
                Object.assign(output, (_b = {}, _b[key] = source[key], _b));
            }
            var _a, _b;
        });
    }
    return output;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Manages the translation data.
 * @record
 */

/**
 * Manages the translation data.
 */
var TranslationService = (function () {
    function TranslationService(configuration, locale, translationProvider, translationHandler) {
        this.configuration = configuration;
        this.locale = locale;
        this.translationProvider = translationProvider;
        this.translationHandler = translationHandler;
        this.translationError = new Subject$1();
        this.translation = new BehaviorSubject$1('');
        /**
         * The translation data: {language: {key: value}}.
         */
        this.translationData = {};
        this.serviceState = ServiceState.isWaiting;
    }
    /**
     * @return {?}
     */
    TranslationService.prototype.getConfiguration = /**
     * @return {?}
     */
    function () {
        return this.configuration;
    };
    /**
     * @return {?}
     */
    TranslationService.prototype.init = /**
     * @return {?}
     */
    function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var translations, _i, translations_1, translation;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.configuration.providers) {
                            this.loadingMode = LoadingMode.Async;
                        }
                        else {
                            this.loadingMode = LoadingMode.Direct;
                            if (this.configuration.translationData) {
                                translations = this.configuration.translationData;
                                for (_i = 0, translations_1 = translations; _i < translations_1.length; _i++) {
                                    translation = translations_1[_i];
                                    this.addData(translation.data, translation.languageCode);
                                }
                            }
                        }
                        // When the language changes, loads translation data.
                        this.locale.loadTranslation.subscribe(function () { _this.loadTranslation(); });
                        return [4 /*yield*/, this.loadTranslation()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Fired when the translation data has been loaded. Returns the translation language.
     * @return {?}
     */
    TranslationService.prototype.translationChanged = /**
     * Fired when the translation data has been loaded. Returns the translation language.
     * @return {?}
     */
    function () {
        return this.translation.asObservable();
    };
    /**
     * Translates a key or an array of keys.
     * @param {?} keys The key or an array of keys to be translated
     * @param {?=} args Optional parameters contained in the key
     * @param {?=} lang The current language of the service is used by default
     * @return {?} The translated value or an object: {key: value}
     */
    TranslationService.prototype.translate = /**
     * Translates a key or an array of keys.
     * @param {?} keys The key or an array of keys to be translated
     * @param {?=} args Optional parameters contained in the key
     * @param {?=} lang The current language of the service is used by default
     * @return {?} The translated value or an object: {key: value}
     */
    function (keys, args, lang) {
        if (args === void 0) { args = null; }
        if (lang === void 0) { lang = this.translation.getValue(); }
        // If the service is not ready, returns the keys.
        if (this.serviceState != ServiceState.isReady)
            return keys;
        if (Array.isArray(keys)) {
            var /** @type {?} */ data = {};
            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                var key = keys_1[_i];
                data[key] = this.translateKey(key, args, lang);
            }
            return data;
        }
        return this.translateKey(keys, args, lang);
    };
    /**
     * @param {?} keys
     * @param {?=} args
     * @param {?=} lang
     * @return {?}
     */
    TranslationService.prototype.translateAsync = /**
     * @param {?} keys
     * @param {?=} args
     * @param {?=} lang
     * @return {?}
     */
    function (keys, args, lang) {
        var _this = this;
        if (lang === void 0) { lang = this.translation.getValue(); }
        return Observable$1.create(function (observer) {
            var /** @type {?} */ values = _this.translate(keys, args, lang);
            observer.next(values);
            observer.complete();
        });
    };
    /**
     * @param {?} key
     * @param {?} args
     * @param {?} lang
     * @return {?}
     */
    TranslationService.prototype.translateKey = /**
     * @param {?} key
     * @param {?} args
     * @param {?} lang
     * @return {?}
     */
    function (key, args, lang) {
        if (key == null || key == "")
            return null;
        // I18n plural.
        if (this.configuration.i18nPlural && /^\d+\b/.exec(key)) {
            return this.translateI18nPlural(key, args, lang);
        }
        return this.getValue(key, args, lang);
    };
    /**
     * @param {?} key
     * @param {?} args
     * @param {?} lang
     * @return {?}
     */
    TranslationService.prototype.getValue = /**
     * @param {?} key
     * @param {?} args
     * @param {?} lang
     * @return {?}
     */
    function (key, args, lang) {
        var /** @type {?} */ path = key;
        var /** @type {?} */ value = null;
        var /** @type {?} */ translation = this.translationData[lang];
        if (translation) {
            // Composed key.
            if (this.configuration.composedKeySeparator) {
                var /** @type {?} */ sequences = key.split(this.configuration.composedKeySeparator);
                key = /** @type {?} */ ((sequences.shift()));
                while (sequences.length > 0 && translation[key]) {
                    translation = translation[key];
                    key = /** @type {?} */ ((sequences.shift()));
                }
            }
            value = translation[key] || translation[this.configuration.missingKey || ""];
        }
        return this.translationHandler.parseValue(path, key, value, args, lang);
    };
    /**
     * @param {?} key
     * @param {?} args
     * @param {?} lang
     * @return {?}
     */
    TranslationService.prototype.translateI18nPlural = /**
     * @param {?} key
     * @param {?} args
     * @param {?} lang
     * @return {?}
     */
    function (key, args, lang) {
        var /** @type {?} */ keyText = key.replace(/^\d+\b/, "");
        keyText = keyText.trim();
        var /** @type {?} */ keyNumber = parseFloat(key);
        key = key.replace(/^\d+/, this.translateNumber(keyNumber));
        return key.replace(keyText, this.getValue(keyText, args, lang));
    };
    /**
     * @param {?} keyNumber
     * @return {?}
     */
    TranslationService.prototype.translateNumber = /**
     * @param {?} keyNumber
     * @return {?}
     */
    function (keyNumber) {
        if (!isNaN(keyNumber) && IntlAPI.hasNumberFormat()) {
            var /** @type {?} */ localeNumber = new Intl.NumberFormat(this.translation.getValue()).format(keyNumber);
            return localeNumber;
        }
        return keyNumber.toString();
    };
    /**
     * @return {?}
     */
    TranslationService.prototype.loadTranslation = /**
     * @return {?}
     */
    function () {
        return __awaiter(this, void 0, void 0, function () {
            var language;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.configuration.composedLanguage) {
                            language = this.composeLanguage(this.configuration.composedLanguage);
                        }
                        else {
                            language = this.locale.getCurrentLanguage();
                        }
                        if (!(language != null)) return [3 /*break*/, 3];
                        if (!(this.loadingMode == LoadingMode.Async)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getTranslation(language).toPromise()];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        this.releaseTranslation(language);
                        _a.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * @param {?} composedLanguage
     * @return {?}
     */
    TranslationService.prototype.composeLanguage = /**
     * @param {?} composedLanguage
     * @return {?}
     */
    function (composedLanguage) {
        var /** @type {?} */ language = "";
        if (composedLanguage.length > 0) {
            for (var /** @type {?} */ i = 0; i <= composedLanguage.length - 1; i++) {
                switch (composedLanguage[i]) {
                    case ISOCode.Script:
                        language += this.locale.getCurrentScript();
                        break;
                    case ISOCode.Country:
                        language += this.locale.getCurrentCountry();
                        break;
                    default:
                        language += this.locale.getCurrentLanguage();
                }
                if (i < composedLanguage.length - 1) {
                    language += "-";
                }
            }
        }
        return language;
    };
    /**
     * @param {?} language
     * @return {?}
     */
    TranslationService.prototype.getTranslation = /**
     * @param {?} language
     * @return {?}
     */
    function (language) {
        var _this = this;
        return Observable$1.create(function (observer) {
            _this.translationData = {};
            _this.serviceState = ServiceState.isLoading;
            var /** @type {?} */ sequencesOfOrderedTranslationData = [];
            var /** @type {?} */ sequencesOfTranslationData = [];
            for (var _i = 0, _a = /** @type {?} */ ((_this.configuration.providers)); _i < _a.length; _i++) {
                var provider = _a[_i];
                if (typeof provider.type !== "undefined" && provider.type == ProviderType.Fallback) {
                    var /** @type {?} */ fallbackLanguage = language;
                    if (provider.fallbackLanguage) {
                        fallbackLanguage = _this.composeLanguage(provider.fallbackLanguage);
                    }
                    sequencesOfOrderedTranslationData.push(_this.translationProvider.getTranslation(fallbackLanguage, provider));
                }
                else {
                    sequencesOfTranslationData.push(_this.translationProvider.getTranslation(language, provider));
                }
            }
            // Merges all the sequences into a single observable sequence.
            var /** @type {?} */ mergedSequencesOfTranslationData = merge$1.apply(void 0, sequencesOfTranslationData);
            sequencesOfOrderedTranslationData.push(mergedSequencesOfTranslationData);
            concat$1.apply(void 0, sequencesOfOrderedTranslationData).subscribe(function (data) {
                _this.addData(data, language);
            }, function (error) {
                // Sends an event for custom actions.
                // Sends an event for custom actions.
                _this.translationError.next(error);
                _this.releaseTranslation(language);
                observer.next(null);
                observer.complete();
            }, function () {
                _this.releaseTranslation(language);
                observer.next(null);
                observer.complete();
            });
        });
    };
    /**
     * @param {?} data
     * @param {?} language
     * @return {?}
     */
    TranslationService.prototype.addData = /**
     * @param {?} data
     * @param {?} language
     * @return {?}
     */
    function (data, language) {
        this.translationData[language] = typeof this.translationData[language] !== "undefined"
            ? mergeDeep(this.translationData[language], data)
            : data;
    };
    /**
     * @param {?} language
     * @return {?}
     */
    TranslationService.prototype.releaseTranslation = /**
     * @param {?} language
     * @return {?}
     */
    function (language) {
        this.serviceState = ServiceState.isReady;
        this.sendEvents(language);
    };
    /**
     * @param {?} language
     * @return {?}
     */
    TranslationService.prototype.sendEvents = /**
     * @param {?} language
     * @return {?}
     */
    function (language) {
        // Sends an event for the services.
        this.translation.next(language);
    };
    TranslationService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    TranslationService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLATION_CONFIG,] },] },
        { type: LocaleService, },
        { type: TranslationProvider, },
        { type: TranslationHandler, },
    ]; };
    return TranslationService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Initializes the services.
 */
var L10nLoader = (function () {
    function L10nLoader(localeConfig, translationConfig, locale, translation) {
        this.localeConfig = localeConfig;
        this.translationConfig = translationConfig;
        this.locale = locale;
        this.translation = translation;
    }
    /**
     * Loads l10n services.
     * @return {?}
     */
    L10nLoader.prototype.load = /**
     * Loads l10n services.
     * @return {?}
     */
    function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(Object.keys(this.localeConfig).length > 0)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.locale.init()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        if (!(Object.keys(this.translationConfig).length > 0)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.translation.init()];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    L10nLoader.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    L10nLoader.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [LOCALE_CONFIG,] },] },
        { type: undefined, decorators: [{ type: Inject, args: [TRANSLATION_CONFIG,] },] },
        { type: LocaleService, },
        { type: TranslationService, },
    ]; };
    return L10nLoader;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Provides 'lang' to the translate pipe.
 */
var Translation = (function () {
    function Translation(changeDetectorRef) {
        var _this = this;
        this.changeDetectorRef = changeDetectorRef;
        this.paramSubscriptions = [];
        this.translation = InjectorRef.get(TranslationService);
        // When the language changes, subscribes to the event & updates lang property.
        this.paramSubscriptions.push(this.translation.translationChanged().subscribe(function (language) {
            _this.lang = language;
            // OnPush Change Detection strategy.
            if (_this.changeDetectorRef) {
                _this.changeDetectorRef.markForCheck();
            }
        }));
    }
    /**
     * @return {?}
     */
    Translation.prototype.cancelParamSubscriptions = /**
     * @return {?}
     */
    function () {
        this.paramSubscriptions.forEach(function (subscription) {
            if (typeof subscription !== "undefined") {
                subscription.unsubscribe();
            }
        });
    };
    Translation.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    Translation.ctorParameters = function () { return [
        { type: ChangeDetectorRef, },
    ]; };
    return Translation;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Provides 'lang' to the translate pipe,
 * 'defaultLocale', 'currency', 'timezone' to l10nDate, l10nDecimal, l10nPercent & l10nCurrency pipes.
 */
var Localization = (function (_super) {
    __extends(Localization, _super);
    function Localization(changeDetectorRef) {
        var _this = _super.call(this) || this;
        _this.changeDetectorRef = changeDetectorRef;
        _this.locale = InjectorRef.get(LocaleService);
        _this.defaultLocale = _this.locale.getDefaultLocale();
        // When the default locale changes, subscribes to the event & updates defaultLocale property.
        // When the default locale changes, subscribes to the event & updates defaultLocale property.
        _this.paramSubscriptions.push(_this.locale.defaultLocaleChanged.subscribe(function (defaultLocale) {
            _this.defaultLocale = defaultLocale;
            // OnPush Change Detection strategy.
            if (_this.changeDetectorRef) {
                _this.changeDetectorRef.markForCheck();
            }
        }));
        _this.currency = _this.locale.getCurrentCurrency();
        // When the currency changes, subscribes to the event & updates currency property.
        // When the currency changes, subscribes to the event & updates currency property.
        _this.paramSubscriptions.push(_this.locale.currencyCodeChanged.subscribe(function (currency) {
            _this.currency = currency;
            // OnPush Change Detection strategy.
            if (_this.changeDetectorRef) {
                _this.changeDetectorRef.markForCheck();
            }
        }));
        _this.timezone = _this.locale.getCurrentTimezone();
        // When the timezone changes, subscribes to the event & updates timezone property.
        // When the timezone changes, subscribes to the event & updates timezone property.
        _this.paramSubscriptions.push(_this.locale.timezoneChanged.subscribe(function (zoneName) {
            _this.timezone = zoneName;
            // OnPush Change Detection strategy.
            if (_this.changeDetectorRef) {
                _this.changeDetectorRef.markForCheck();
            }
        }));
        return _this;
    }
    Localization.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    Localization.ctorParameters = function () { return [
        { type: ChangeDetectorRef, },
    ]; };
    return Localization;
}(Translation));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Provides the methods for locale validation.
 * @record
 */

/**
 * Provides the methods for locale validation.
 */
var LocaleValidation = (function () {
    function LocaleValidation(locale) {
        this.locale = locale;
    }
    /**
     * Converts a string to a number according to default locale.
     * If the string cannot be converted to a number, returns NaN.
     * @param {?} s
     * @param {?=} defaultLocale
     * @return {?}
     */
    LocaleValidation.prototype.parseNumber = /**
     * Converts a string to a number according to default locale.
     * If the string cannot be converted to a number, returns NaN.
     * @param {?} s
     * @param {?=} defaultLocale
     * @return {?}
     */
    function (s, defaultLocale) {
        if (defaultLocale === void 0) { defaultLocale = this.locale.getDefaultLocale(); }
        if (s == "" || s == null) {
            return null;
        }
        var /** @type {?} */ value = "";
        var /** @type {?} */ decimalCode = this.getDecimalCode(defaultLocale);
        var /** @type {?} */ numberCodes = this.getNumberCodes(defaultLocale);
        var /** @type {?} */ characters = s.split("");
        for (var _i = 0, characters_1 = characters; _i < characters_1.length; _i++) {
            var char = characters_1[_i];
            var /** @type {?} */ charCode = this.toUnicode(char);
            var /** @type {?} */ index = numberCodes.indexOf(charCode);
            if (index != -1) {
                value += index;
            }
            else if (charCode == decimalCode.minusSign) {
                value += "-";
            }
            else if (charCode == decimalCode.decimalSeparator) {
                value += ".";
            }
            else if (charCode == decimalCode.thousandSeparator) {
                continue;
            }
            else {
                return NaN;
            }
        }
        return parseFloat(value);
    };
    /**
     * @param {?} digits
     * @param {?=} defaultLocale
     * @return {?}
     */
    LocaleValidation.prototype.getRegExp = /**
     * @param {?} digits
     * @param {?=} defaultLocale
     * @return {?}
     */
    function (digits, defaultLocale) {
        if (defaultLocale === void 0) { defaultLocale = this.locale.getDefaultLocale(); }
        var /** @type {?} */ minInt = 1;
        var /** @type {?} */ minFraction = 0;
        var /** @type {?} */ maxFraction = 3;
        if (!!digits) {
            var /** @type {?} */ NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(\-(\d+))?)?$/;
            var /** @type {?} */ parts = digits.match(NUMBER_FORMAT_REGEXP);
            if (parts != null) {
                if (parts[1] != null) {
                    // Min integer digits.
                    minInt = parseInt(parts[1]);
                }
                if (parts[3] != null) {
                    // Min fraction digits.
                    minFraction = parseInt(parts[3]);
                }
                if (parts[5] != null) {
                    // Max fraction digits.
                    maxFraction = parseInt(parts[5]);
                }
            }
        }
        var /** @type {?} */ decimalCode = this.getDecimalCode(defaultLocale);
        var /** @type {?} */ numberCodes = this.getNumberCodes(defaultLocale);
        var /** @type {?} */ minusSign = decimalCode.minusSign;
        var /** @type {?} */ zero = numberCodes[0];
        var /** @type {?} */ decimalSeparator = decimalCode.decimalSeparator;
        var /** @type {?} */ thousandSeparator = decimalCode.thousandSeparator;
        var /** @type {?} */ nine = numberCodes[9];
        // Pattern for 1.0-2 digits: /^-?[0-9]{1,}(\.[0-9]{0,2})?$/
        // Unicode pattern = "^\u002d?[\u0030-\u0039]{1,}(\\u002e[\u0030-\u0039]{0,2})?$"
        // Complete Pattern with thousand separator:
        // /^-?([0-9]{1,}|(?=(?:\,*[0-9]){1,}(\.|$))(?!0(?!\.|[0-9]))[0-9]{1,3}(\,[0-9]{3})*)(\.[0-9]{0,2})?$/
        // where:
        // (?=(?:\,*[0-9]){1,}(\.|$)) => Positive Lookahead to count the integer digits
        // (?!0(?!\.|[0-9])) => Negative Lookahead to avoid 0,1111.00
        // [0-9]{1,3}(\,[0-9]{3})* => Allows thousand separator
        var /** @type {?} */ d = "[" + zero + "-" + nine + "]";
        var /** @type {?} */ n = "{" + minInt + ",}";
        var /** @type {?} */ nm = "{" + minFraction + "," + maxFraction + "}";
        var /** @type {?} */ plainPattern = "" + d + n;
        // tslint:disable-next-line
        var /** @type {?} */ thousandPattern = "(?=(?:\\" + thousandSeparator + "*" + d + ")" + n + "(\\" + decimalSeparator + "|$))(?!" + zero + "(?!\\" + decimalSeparator + "|" + d + "))" + d + "{1,3}(\\" + thousandSeparator + d + "{3})*";
        var /** @type {?} */ pattern = "^" + minusSign + "?(" + plainPattern + "|" + thousandPattern + ")";
        if (minFraction > 0 && maxFraction > 0) {
            // Decimal separator is mandatory.
            pattern += "\\" + decimalSeparator + d + nm + "$";
        }
        else if (minFraction == 0 && maxFraction > 0) {
            // Decimal separator is optional.
            pattern += "(\\" + decimalSeparator + d + nm + ")?$";
        }
        else {
            // Integer number.
            pattern += "$";
        }
        pattern = this.toChar(pattern);
        var /** @type {?} */ regExp = new RegExp(pattern);
        return regExp;
    };
    /**
     * @param {?} defaultLocale
     * @return {?}
     */
    LocaleValidation.prototype.getDecimalCode = /**
     * @param {?} defaultLocale
     * @return {?}
     */
    function (defaultLocale) {
        var /** @type {?} */ decimalCode = {
            minusSign: this.toUnicode("-"),
            decimalSeparator: this.toUnicode("."),
            thousandSeparator: this.toUnicode(",")
        };
        if (IntlAPI.hasNumberFormat()) {
            var /** @type {?} */ value = -1000.9; // Reference value.
            var /** @type {?} */ localeValue = new Intl.NumberFormat(defaultLocale).format(value);
            var /** @type {?} */ unicodeChars = [];
            for (var /** @type {?} */ i = 0; i <= 7; i++) {
                unicodeChars.push(this.toUnicode(localeValue.charAt(i)));
            }
            // Right to left:
            // checks Unicode characters 'RIGHT-TO-LEFT MARK' (U+200F) & 'Arabic Letter Mark' (U+061C),
            // or the reverse order.
            // Left to right:
            // checks Unicode character 'LEFT-TO-RIGHT MARK' (U+200E).
            if (unicodeChars[0] == "\\u200F" || unicodeChars[0] == "\\u061C") {
                decimalCode = {
                    minusSign: unicodeChars[1],
                    decimalSeparator: unicodeChars[7],
                    thousandSeparator: unicodeChars[3]
                };
            }
            else if (unicodeChars[0] == this.toUnicode(new Intl.NumberFormat(defaultLocale).format(1))) {
                decimalCode = {
                    minusSign: unicodeChars[7],
                    decimalSeparator: unicodeChars[5],
                    thousandSeparator: unicodeChars[1]
                };
            }
            else if (unicodeChars[0] == "\\u200E") {
                decimalCode = {
                    minusSign: unicodeChars[1],
                    decimalSeparator: unicodeChars[7],
                    thousandSeparator: unicodeChars[3]
                };
            }
            else {
                decimalCode = {
                    minusSign: unicodeChars[0],
                    decimalSeparator: unicodeChars[6],
                    thousandSeparator: unicodeChars[2]
                };
            }
        }
        return decimalCode;
    };
    /**
     * @param {?} defaultLocale
     * @return {?}
     */
    LocaleValidation.prototype.getNumberCodes = /**
     * @param {?} defaultLocale
     * @return {?}
     */
    function (defaultLocale) {
        var /** @type {?} */ numberCodes = [];
        for (var /** @type {?} */ num = 0; num <= 9; num++) {
            numberCodes.push(this.toUnicode(num.toString()));
        }
        if (IntlAPI.hasNumberFormat()) {
            for (var /** @type {?} */ num = 0; num <= 9; num++) {
                numberCodes[num] = this.toUnicode(new Intl.NumberFormat(defaultLocale).format(num));
            }
        }
        return numberCodes;
    };
    /**
     * @param {?} pattern
     * @return {?}
     */
    LocaleValidation.prototype.toChar = /**
     * @param {?} pattern
     * @return {?}
     */
    function (pattern) {
        return pattern.replace(/\\u[\dA-F]{4}/gi, function (match) {
            return String.fromCharCode(parseInt(match.replace(/\\u/g, ""), 16));
        });
    };
    /**
     * @param {?} c
     * @return {?}
     */
    LocaleValidation.prototype.toUnicode = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return "\\u" + this.toHex(c.charCodeAt(0));
    };
    /**
     * @param {?} value
     * @return {?}
     */
    LocaleValidation.prototype.toHex = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var /** @type {?} */ hex = value.toString(16).toUpperCase();
        // With padding.
        hex = "0000".substr(0, 4 - hex.length) + hex;
        return hex;
    };
    LocaleValidation.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    LocaleValidation.ctorParameters = function () { return [
        { type: LocaleService, },
    ]; };
    return LocaleValidation;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Intl.Collator APIs.
 * @record
 */

/**
 * Intl.Collator APIs.
 */
var Collator = (function () {
    function Collator(locale, translation) {
        this.locale = locale;
        this.translation = translation;
    }
    /**
     * Compares two keys by the value of translation according to the current language.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     * @param {?} key1
     * @param {?} key2
     * @param {?=} extension Unicode extension key, e.g. 'co-phonebk'
     * @param {?=} options Default is { usage: 'sort', sensitivity: 'variant' }
     * @return {?} A negative value if the value of translation of key1 comes before the value of translation of key2;
     *         a positive value if key1 comes after key2;
     *         0 if they are considered equal or Intl.Collator is not supported
     */
    Collator.prototype.compare = /**
     * Compares two keys by the value of translation according to the current language.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     * @param {?} key1
     * @param {?} key2
     * @param {?=} extension Unicode extension key, e.g. 'co-phonebk'
     * @param {?=} options Default is { usage: 'sort', sensitivity: 'variant' }
     * @return {?} A negative value if the value of translation of key1 comes before the value of translation of key2;
     *         a positive value if key1 comes after key2;
     *         0 if they are considered equal or Intl.Collator is not supported
     */
    function (key1, key2, extension, options) {
        if (options === void 0) { options = { usage: 'sort', sensitivity: 'variant' }; }
        if (!IntlAPI.hasCollator()) {
            return 0;
        }
        var /** @type {?} */ value1 = this.translation.translate(key1);
        var /** @type {?} */ value2 = this.translation.translate(key2);
        var /** @type {?} */ locale = this.addExtension(this.locale.getCurrentLocale(), extension);
        return new Intl.Collator(locale, options).compare(value1, value2);
    };
    /**
     * Sorts an array of objects or an array of arrays according to the current language.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     * @param {?} list The array to be sorted
     * @param {?} keyName The column that contains the keys of the values to be ordered
     * @param {?=} order 'asc' or 'desc'. The default value is 'asc'
     * @param {?=} extension Unicode extension key, e.g. 'co-phonebk'
     * @param {?=} options Default is { usage: 'sort', sensitivity: 'variant' }
     * @return {?} The same sorted list or the same list if Intl.Collator is not supported
     */
    Collator.prototype.sort = /**
     * Sorts an array of objects or an array of arrays according to the current language.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     * @param {?} list The array to be sorted
     * @param {?} keyName The column that contains the keys of the values to be ordered
     * @param {?=} order 'asc' or 'desc'. The default value is 'asc'
     * @param {?=} extension Unicode extension key, e.g. 'co-phonebk'
     * @param {?=} options Default is { usage: 'sort', sensitivity: 'variant' }
     * @return {?} The same sorted list or the same list if Intl.Collator is not supported
     */
    function (list, keyName, order, extension, options) {
        var _this = this;
        if (order === void 0) { order = "asc"; }
        if (options === void 0) { options = { usage: 'sort', sensitivity: 'variant' }; }
        if (!list || !keyName || !IntlAPI.hasCollator()) {
            return list;
        }
        list.sort(function (key1, key2) {
            return _this.compare(key1[keyName], key2[keyName], extension, options);
        });
        if (order == "desc") {
            list.reverse();
        }
        return list;
    };
    /**
     * Sorts asynchronously an array of objects or an array of arrays according to the current language.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     * @param {?} list The array to be sorted
     * @param {?} keyName The column that contains the keys of the values to be ordered
     * @param {?=} order 'asc' or 'desc'. The default value is 'asc'
     * @param {?=} extension Unicode extension key, e.g. 'co-phonebk'
     * @param {?=} options Default is { usage: 'sort', sensitivity: 'variant' }
     * @return {?} An observable of the sorted list or of the same list if Intl.Collator is not supported
     */
    Collator.prototype.sortAsync = /**
     * Sorts asynchronously an array of objects or an array of arrays according to the current language.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     * @param {?} list The array to be sorted
     * @param {?} keyName The column that contains the keys of the values to be ordered
     * @param {?=} order 'asc' or 'desc'. The default value is 'asc'
     * @param {?=} extension Unicode extension key, e.g. 'co-phonebk'
     * @param {?=} options Default is { usage: 'sort', sensitivity: 'variant' }
     * @return {?} An observable of the sorted list or of the same list if Intl.Collator is not supported
     */
    function (list, keyName, order, extension, options) {
        var _this = this;
        if (options === void 0) { options = { usage: 'sort', sensitivity: 'variant' }; }
        return Observable$1.create(function (observer) {
            observer.next(_this.sort(list, keyName, order, extension, options));
            observer.complete();
        });
    };
    /**
     * Matches a string into an array of objects or an array of arrays
     * according to the current language.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     * @param {?} s The string to search
     * @param {?} list The array in which to search
     * @param {?} keyNames An array that contains the columns to look for
     * @param {?=} options Default is { usage: 'search' }
     * @return {?} A filtered list or the same list if Intl.Collator is not supported
     */
    Collator.prototype.search = /**
     * Matches a string into an array of objects or an array of arrays
     * according to the current language.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     * @param {?} s The string to search
     * @param {?} list The array in which to search
     * @param {?} keyNames An array that contains the columns to look for
     * @param {?=} options Default is { usage: 'search' }
     * @return {?} A filtered list or the same list if Intl.Collator is not supported
     */
    function (s, list, keyNames, options) {
        var _this = this;
        if (options === void 0) { options = { usage: 'search' }; }
        if (!list || !keyNames || s == "" || s == null || !IntlAPI.hasCollator()) {
            return list;
        }
        var /** @type {?} */ locale = this.locale.getCurrentLocale();
        var /** @type {?} */ collator = new Intl.Collator(locale, options);
        var /** @type {?} */ matches = list.filter(function (key) {
            var /** @type {?} */ found = false;
            for (var /** @type {?} */ i = 0; i < keyNames.length; i++) {
                if (_this.match(key[keyNames[i]], s, collator)) {
                    found = true;
                    break;
                }
            }
            return found;
        });
        return matches;
    };
    /**
     * Matches asynchronously a string into an array of objects or an array of arrays
     * according to the current language.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     * @param {?} s The string to search
     * @param {?} list The array in which to search
     * @param {?} keyNames An array that contains the columns to look for
     * @param {?=} options Default is { usage: 'search' }
     * @return {?} An observable of the filtered list or the same list if Intl.Collator is not supported
     */
    Collator.prototype.searchAsync = /**
     * Matches asynchronously a string into an array of objects or an array of arrays
     * according to the current language.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     * @param {?} s The string to search
     * @param {?} list The array in which to search
     * @param {?} keyNames An array that contains the columns to look for
     * @param {?=} options Default is { usage: 'search' }
     * @return {?} An observable of the filtered list or the same list if Intl.Collator is not supported
     */
    function (s, list, keyNames, options) {
        var _this = this;
        if (options === void 0) { options = { usage: 'search' }; }
        return Observable$1.create(function (observer) {
            observer.next(_this.search(s, list, keyNames, options));
            observer.complete();
        });
    };
    /**
     * @param {?} locale
     * @param {?=} extension
     * @return {?}
     */
    Collator.prototype.addExtension = /**
     * @param {?} locale
     * @param {?=} extension
     * @return {?}
     */
    function (locale, extension) {
        if (!!extension) {
            locale = locale + "-u-" + extension;
        }
        return locale;
    };
    /**
     * @param {?} key
     * @param {?} s
     * @param {?} collator
     * @return {?}
     */
    Collator.prototype.match = /**
     * @param {?} key
     * @param {?} s
     * @param {?} collator
     * @return {?}
     */
    function (key, s, collator) {
        var /** @type {?} */ value = this.translation.translate(key);
        var /** @type {?} */ valueLength = value.length;
        var /** @type {?} */ sLength = s.length;
        if (sLength > valueLength) {
            return false;
        }
        if (sLength == valueLength) {
            return collator.compare(value, s) == 0;
        }
        var /** @type {?} */ found = false;
        for (var /** @type {?} */ i = 0; i < valueLength - (sLength - 1); i++) {
            var /** @type {?} */ str = value.substr(i, sLength);
            if (collator.compare(str, s) == 0) {
                found = true;
                break;
            }
        }
        return found;
    };
    Collator.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    Collator.ctorParameters = function () { return [
        { type: LocaleService, },
        { type: TranslationService, },
    ]; };
    return Collator;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Property decorator for components to provide the parameter to the translate pipe.
 * @return {?}
 */
function Language() {
    /**
     * @param {?} target
     * @param {?=} propertyKey
     * @return {?}
     */
    function DecoratorFactory(target, propertyKey) {
        var /** @type {?} */ subscription;
        var /** @type {?} */ targetNgOnInit = target.ngOnInit;
        /**
         * @this {?}
         * @return {?}
         */
        function ngOnInit() {
            var _this = this;
            var /** @type {?} */ translation = InjectorRef.get(TranslationService);
            if (typeof propertyKey !== "undefined") {
                // When the language changes, subscribes to the event & updates language property.
                subscription = translation.translationChanged().subscribe(function (language) {
                    _this[propertyKey] = language;
                });
            }
            if (targetNgOnInit) {
                targetNgOnInit.apply(this);
            }
        }
        target.ngOnInit = ngOnInit;
        var /** @type {?} */ targetNgOnDestroy = target.ngOnDestroy;
        /**
         * @this {?}
         * @return {?}
         */
        function ngOnDestroy() {
            if (typeof subscription !== "undefined") {
                subscription.unsubscribe();
            }
            if (targetNgOnDestroy) {
                targetNgOnDestroy.apply(this);
            }
        }
        target.ngOnDestroy = ngOnDestroy;
        if (typeof propertyKey !== "undefined") {
            Object.defineProperty(target, propertyKey, {
                writable: true,
                value: undefined
            });
        }
    }
    return DecoratorFactory;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Property decorator for components to provide the parameter
 * to l10nDate, l10nDecimal, l10nPercent & l10nCurrency pipes.
 * @return {?}
 */
function DefaultLocale$1() {
    /**
     * @param {?} target
     * @param {?=} propertyKey
     * @return {?}
     */
    function DecoratorFactory(target, propertyKey) {
        var /** @type {?} */ subscription;
        var /** @type {?} */ targetNgOnInit = target.ngOnInit;
        /**
         * @this {?}
         * @return {?}
         */
        function ngOnInit() {
            var _this = this;
            var /** @type {?} */ locale = InjectorRef.get(LocaleService);
            if (typeof propertyKey !== "undefined") {
                this[propertyKey] = locale.getDefaultLocale();
                // When the default locale changes, subscribes to the event & updates defaultLocale property.
                subscription = locale.defaultLocaleChanged.subscribe(function (defaultLocale) {
                    _this[propertyKey] = defaultLocale;
                });
            }
            if (targetNgOnInit) {
                targetNgOnInit.apply(this);
            }
        }
        target.ngOnInit = ngOnInit;
        var /** @type {?} */ targetNgOnDestroy = target.ngOnDestroy;
        /**
         * @this {?}
         * @return {?}
         */
        function ngOnDestroy() {
            if (typeof subscription !== "undefined") {
                subscription.unsubscribe();
            }
            if (targetNgOnDestroy) {
                targetNgOnDestroy.apply(this);
            }
        }
        target.ngOnDestroy = ngOnDestroy;
        if (typeof propertyKey !== "undefined") {
            Object.defineProperty(target, propertyKey, {
                writable: true,
                value: undefined
            });
        }
    }
    return DecoratorFactory;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Property decorator for components to provide the parameter to the l10nCurrency pipe.
 * @return {?}
 */
function Currency() {
    /**
     * @param {?} target
     * @param {?=} propertyKey
     * @return {?}
     */
    function DecoratorFactory(target, propertyKey) {
        var /** @type {?} */ subscription;
        var /** @type {?} */ targetNgOnInit = target.ngOnInit;
        /**
         * @this {?}
         * @return {?}
         */
        function ngOnInit() {
            var _this = this;
            var /** @type {?} */ locale = InjectorRef.get(LocaleService);
            if (typeof propertyKey !== "undefined") {
                this[propertyKey] = locale.getCurrentCurrency();
                // When the currency changes, subscribes to the event & updates currency property.
                subscription = locale.currencyCodeChanged.subscribe(function (currency) {
                    _this[propertyKey] = currency;
                });
            }
            if (targetNgOnInit) {
                targetNgOnInit.apply(this);
            }
        }
        target.ngOnInit = ngOnInit;
        var /** @type {?} */ targetNgOnDestroy = target.ngOnDestroy;
        /**
         * @this {?}
         * @return {?}
         */
        function ngOnDestroy() {
            if (typeof subscription !== "undefined") {
                subscription.unsubscribe();
            }
            if (targetNgOnDestroy) {
                targetNgOnDestroy.apply(this);
            }
        }
        target.ngOnDestroy = ngOnDestroy;
        if (typeof propertyKey !== "undefined") {
            Object.defineProperty(target, propertyKey, {
                writable: true,
                value: undefined
            });
        }
    }
    return DecoratorFactory;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Property decorator for components to provide the parameter to the l10nDate pipe.
 * @return {?}
 */
function Timezone() {
    /**
     * @param {?} target
     * @param {?=} propertyKey
     * @return {?}
     */
    function DecoratorFactory(target, propertyKey) {
        var /** @type {?} */ subscription;
        var /** @type {?} */ targetNgOnInit = target.ngOnInit;
        /**
         * @this {?}
         * @return {?}
         */
        function ngOnInit() {
            var _this = this;
            var /** @type {?} */ locale = InjectorRef.get(LocaleService);
            if (typeof propertyKey !== "undefined") {
                this[propertyKey] = locale.getCurrentTimezone();
                // When the timezone changes, subscribes to the event & updates timezone property.
                subscription = locale.timezoneChanged.subscribe(function (zoneName) {
                    _this[propertyKey] = zoneName;
                });
            }
            if (targetNgOnInit) {
                targetNgOnInit.apply(this);
            }
        }
        target.ngOnInit = ngOnInit;
        var /** @type {?} */ targetNgOnDestroy = target.ngOnDestroy;
        /**
         * @this {?}
         * @return {?}
         */
        function ngOnDestroy() {
            if (typeof subscription !== "undefined") {
                subscription.unsubscribe();
            }
            if (targetNgOnDestroy) {
                targetNgOnDestroy.apply(this);
            }
        }
        target.ngOnDestroy = ngOnDestroy;
        if (typeof propertyKey !== "undefined") {
            Object.defineProperty(target, propertyKey, {
                writable: true,
                value: undefined
            });
        }
    }
    return DecoratorFactory;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TranslatePipe = (function () {
    function TranslatePipe(translation) {
        this.translation = translation;
    }
    /**
     * @param {?} key
     * @param {?} lang
     * @param {?=} args
     * @return {?}
     */
    TranslatePipe.prototype.transform = /**
     * @param {?} key
     * @param {?} lang
     * @param {?=} args
     * @return {?}
     */
    function (key, lang, args) {
        return this.translation.translate(key, args, lang);
    };
    TranslatePipe.decorators = [
        { type: Pipe, args: [{
                    name: 'translate',
                    pure: true
                },] },
    ];
    /** @nocollapse */
    TranslatePipe.ctorParameters = function () { return [
        { type: TranslationService, },
    ]; };
    return TranslatePipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @param {?} date
 * @param {?} defaultLocale
 * @param {?} options
 * @param {?=} timezone
 * @return {?}
 */
function intlDateTimeFormat(date, defaultLocale, options, timezone) {
    var /** @type {?} */ marks = /[\u200e\u200f]/g;
    options.timeZone = IntlAPI.hasTimezone() ? timezone : 'UTC';
    return new Intl.DateTimeFormat(defaultLocale, options).format(date).replace(marks, "");
}
/**
 * @param {?} options
 * @return {?}
 */
function datePartFactory(options) {
    var /** @type {?} */ dateFactory = function (date, defaultLocale, timezone) {
        return intlDateTimeFormat(date, defaultLocale, options, timezone);
    };
    return dateFactory;
}
/**
 * @param {?} options
 * @return {?}
 */
function combine(options) {
    var /** @type {?} */ reducedOptions = options.reduce(function (merged, opt) { return (__assign({}, merged, opt)); }, {});
    return reducedOptions;
}
/**
 * @param {?} prop
 * @param {?} len
 * @return {?}
 */
function digitCondition(prop, len) {
    var /** @type {?} */ result = {};
    result[prop] = len === 2 ? '2-digit' : 'numeric';
    return result;
}
/**
 * @param {?} prop
 * @param {?} len
 * @return {?}
 */
function nameCondition(prop, len) {
    var /** @type {?} */ result = {};
    if (len < 4) {
        result[prop] = len > 1 ? 'short' : 'narrow';
    }
    else {
        result[prop] = 'long';
    }
    return result;
}
var FORMAT_ALIASES = {
    'short': datePartFactory(combine([
        digitCondition('year', 1),
        digitCondition('month', 1),
        digitCondition('day', 1),
        digitCondition('hour', 1),
        digitCondition('minute', 1)
    ])),
    'medium': datePartFactory(combine([
        digitCondition('year', 1),
        nameCondition('month', 3),
        digitCondition('day', 1),
        digitCondition('hour', 1),
        digitCondition('minute', 1),
        digitCondition('second', 1),
    ])),
    'shortDate': datePartFactory(combine([
        digitCondition('year', 1),
        digitCondition('month', 1),
        digitCondition('day', 1)
    ])),
    'mediumDate': datePartFactory(combine([
        digitCondition('year', 1),
        nameCondition('month', 3),
        digitCondition('day', 1)
    ])),
    'longDate': datePartFactory(combine([
        digitCondition('year', 1),
        nameCondition('month', 4),
        digitCondition('day', 1)
    ])),
    'fullDate': datePartFactory(combine([
        digitCondition('year', 1),
        nameCondition('month', 4),
        nameCondition('weekday', 4),
        digitCondition('day', 1)
    ])),
    'shortTime': datePartFactory(combine([
        digitCondition('hour', 1),
        digitCondition('minute', 1)
    ])),
    'mediumTime': datePartFactory(combine([
        digitCondition('hour', 1),
        digitCondition('second', 1),
        digitCondition('minute', 1)
    ])),
};
var IntlFormatter = (function () {
    function IntlFormatter() {
    }
    /**
     * @param {?} num
     * @param {?} defaultLocale
     * @param {?} style
     * @param {?=} digits
     * @param {?=} currency
     * @param {?=} currencyDisplay
     * @return {?}
     */
    IntlFormatter.formatNumber = /**
     * @param {?} num
     * @param {?} defaultLocale
     * @param {?} style
     * @param {?=} digits
     * @param {?=} currency
     * @param {?=} currencyDisplay
     * @return {?}
     */
    function (num, defaultLocale, style, digits, currency, currencyDisplay) {
        var /** @type {?} */ minInt;
        var /** @type {?} */ minFraction;
        var /** @type {?} */ maxFraction;
        if (style !== NumberFormatStyle.Currency) {
            minInt = 1;
            minFraction = 0;
            maxFraction = 3;
        }
        if (!!digits) {
            var /** @type {?} */ NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(\-(\d+))?)?$/;
            var /** @type {?} */ parts = digits.match(NUMBER_FORMAT_REGEXP);
            if (parts != null) {
                if (parts[1] != null) {
                    // Min integer digits.
                    minInt = parseInt(parts[1]);
                }
                if (parts[3] != null) {
                    // Min fraction digits.
                    minFraction = parseInt(parts[3]);
                }
                if (parts[5] != null) {
                    // Max fraction digits.
                    maxFraction = parseInt(parts[5]);
                }
            }
        }
        return IntlFormatter.numberFormatter(num, defaultLocale, style, {
            minimumIntegerDigits: minInt,
            minimumFractionDigits: minFraction,
            maximumFractionDigits: maxFraction,
            currency: currency,
            currencyDisplay: currencyDisplay
        });
    };
    /**
     * @param {?} date
     * @param {?} defaultLocale
     * @param {?} format
     * @param {?=} timezone
     * @return {?}
     */
    IntlFormatter.formatDate = /**
     * @param {?} date
     * @param {?} defaultLocale
     * @param {?} format
     * @param {?=} timezone
     * @return {?}
     */
    function (date, defaultLocale, format, timezone) {
        return IntlFormatter.dateTimeFormatter(date, defaultLocale, format, timezone);
    };
    /**
     * @param {?} num
     * @param {?} defaultLocale
     * @param {?} style
     * @param {?=} opts
     * @return {?}
     */
    IntlFormatter.numberFormatter = /**
     * @param {?} num
     * @param {?} defaultLocale
     * @param {?} style
     * @param {?=} opts
     * @return {?}
     */
    function (num, defaultLocale, style, opts) {
        if (opts === void 0) { opts = {}; }
        var minimumIntegerDigits = opts.minimumIntegerDigits, minimumFractionDigits = opts.minimumFractionDigits, maximumFractionDigits = opts.maximumFractionDigits, currency = opts.currency, currencyDisplay = opts.currencyDisplay;
        var /** @type {?} */ options = {
            minimumIntegerDigits: minimumIntegerDigits,
            minimumFractionDigits: minimumFractionDigits,
            maximumFractionDigits: maximumFractionDigits,
            style: NumberFormatStyle[style].toLowerCase()
        };
        if (style == NumberFormatStyle.Currency) {
            options.currency = currency;
            options.currencyDisplay = currencyDisplay;
        }
        return new Intl.NumberFormat(defaultLocale, options).format(num);
    };
    /**
     * @param {?} date
     * @param {?} defaultLocale
     * @param {?} format
     * @param {?=} timezone
     * @return {?}
     */
    IntlFormatter.dateTimeFormatter = /**
     * @param {?} date
     * @param {?} defaultLocale
     * @param {?} format
     * @param {?=} timezone
     * @return {?}
     */
    function (date, defaultLocale, format, timezone) {
        var /** @type {?} */ options = {};
        if (typeof format === "string") {
            var /** @type {?} */ fnFormatAliases = FORMAT_ALIASES[format];
            if (fnFormatAliases)
                return fnFormatAliases(date, defaultLocale, timezone);
        }
        else {
            options = format;
        }
        // If the format is wrong, returns the default Intl format.
        return intlDateTimeFormat(date, defaultLocale, options, timezone);
    };
    return IntlFormatter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var L10nDatePipe = (function () {
    function L10nDatePipe() {
        this.ISO8601_DATE_REGEX = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
    }
    /**
     * @param {?} value
     * @param {?} defaultLocale
     * @param {?=} format
     * @param {?=} timezone
     * @return {?}
     */
    L10nDatePipe.prototype.transform = /**
     * @param {?} value
     * @param {?} defaultLocale
     * @param {?=} format
     * @param {?=} timezone
     * @return {?}
     */
    function (value, defaultLocale, format, timezone) {
        if (format === void 0) { format = 'mediumDate'; }
        if (value == null || value === "" || value !== value)
            return null;
        if (typeof defaultLocale === "undefined")
            return null;
        if (IntlAPI.hasDateTimeFormat()) {
            var /** @type {?} */ date = void 0;
            if (typeof value === "string") {
                value = value.trim();
            }
            if (this.isDate(value)) {
                date = value;
            }
            else if (!isNaN(value - parseFloat(value))) {
                date = new Date(parseFloat(value));
            }
            else if (typeof value === "string" && /^(\d{4}-\d{1,2}-\d{1,2})$/.test(value)) {
                var _a = value.split('-').map(function (val) { return parseInt(val, 10); }), y = _a[0], m = _a[1], d = _a[2];
                date = new Date(y, m - 1, d);
            }
            else {
                date = new Date(value);
            }
            if (!this.isDate(date)) {
                var /** @type {?} */ match = void 0;
                if ((typeof value === "string") && (match = value.match(this.ISO8601_DATE_REGEX))) {
                    date = this.isoStringToDate(match);
                }
            }
            return IntlFormatter.formatDate(date, defaultLocale, format, timezone);
        }
        // Returns the date without localization.
        return value;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    L10nDatePipe.prototype.isDate = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return value instanceof Date && !isNaN(value.valueOf());
    };
    /**
     * @param {?} match
     * @return {?}
     */
    L10nDatePipe.prototype.isoStringToDate = /**
     * @param {?} match
     * @return {?}
     */
    function (match) {
        var /** @type {?} */ date = new Date(0);
        var /** @type {?} */ tzHour = 0;
        var /** @type {?} */ tzMin = 0;
        var /** @type {?} */ dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear;
        var /** @type {?} */ timeSetter = match[8] ? date.setUTCHours : date.setHours;
        if (match[9]) {
            tzHour = +(match[9] + match[10]);
            tzMin = +(match[9] + match[11]);
        }
        dateSetter.call(date, +(match[1]), +(match[2]) - 1, +(match[3]));
        var /** @type {?} */ h = +(match[4] || '0') - tzHour;
        var /** @type {?} */ m = +(match[5] || '0') - tzMin;
        var /** @type {?} */ s = +(match[6] || '0');
        var /** @type {?} */ ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
        timeSetter.call(date, h, m, s, ms);
        return date;
    };
    L10nDatePipe.decorators = [
        { type: Pipe, args: [{
                    name: 'l10nDate',
                    pure: true
                },] },
    ];
    /** @nocollapse */
    L10nDatePipe.ctorParameters = function () { return []; };
    return L10nDatePipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var L10nDecimalPipe = (function () {
    function L10nDecimalPipe() {
    }
    /**
     * @param {?} value
     * @param {?} defaultLocale
     * @param {?=} digits
     * @return {?}
     */
    L10nDecimalPipe.prototype.transform = /**
     * @param {?} value
     * @param {?} defaultLocale
     * @param {?=} digits
     * @return {?}
     */
    function (value, defaultLocale, digits) {
        if (value == null)
            return null;
        if (typeof defaultLocale === "undefined")
            return null;
        if (IntlAPI.hasNumberFormat()) {
            value = typeof value === "string" && !isNaN(+value - parseFloat(value)) ? +value : value;
            return IntlFormatter.formatNumber(value, defaultLocale, NumberFormatStyle.Decimal, digits);
        }
        // Returns the number without localization.
        return value;
    };
    L10nDecimalPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'l10nDecimal',
                    pure: true
                },] },
    ];
    /** @nocollapse */
    L10nDecimalPipe.ctorParameters = function () { return []; };
    return L10nDecimalPipe;
}());
var L10nPercentPipe = (function () {
    function L10nPercentPipe() {
    }
    /**
     * @param {?} value
     * @param {?} defaultLocale
     * @param {?=} digits
     * @return {?}
     */
    L10nPercentPipe.prototype.transform = /**
     * @param {?} value
     * @param {?} defaultLocale
     * @param {?=} digits
     * @return {?}
     */
    function (value, defaultLocale, digits) {
        if (value == null)
            return null;
        if (typeof defaultLocale === "undefined")
            return null;
        if (IntlAPI.hasNumberFormat()) {
            value = typeof value === "string" && !isNaN(+value - parseFloat(value)) ? +value : value;
            return IntlFormatter.formatNumber(value, defaultLocale, NumberFormatStyle.Percent, digits);
        }
        // Returns the number without localization.
        return value;
    };
    L10nPercentPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'l10nPercent',
                    pure: true
                },] },
    ];
    /** @nocollapse */
    L10nPercentPipe.ctorParameters = function () { return []; };
    return L10nPercentPipe;
}());
var L10nCurrencyPipe = (function () {
    function L10nCurrencyPipe() {
    }
    /**
     * @param {?} value
     * @param {?} defaultLocale
     * @param {?} currency
     * @param {?=} currencyDisplay
     * @param {?=} digits
     * @return {?}
     */
    L10nCurrencyPipe.prototype.transform = /**
     * @param {?} value
     * @param {?} defaultLocale
     * @param {?} currency
     * @param {?=} currencyDisplay
     * @param {?=} digits
     * @return {?}
     */
    function (value, defaultLocale, currency, currencyDisplay, digits) {
        if (currencyDisplay === void 0) { currencyDisplay = 'symbol'; }
        if (value == null)
            return null;
        if (typeof defaultLocale === "undefined" || typeof currency === "undefined")
            return null;
        if (IntlAPI.hasNumberFormat()) {
            value = typeof value === "string" && !isNaN(+value - parseFloat(value)) ? +value : value;
            return IntlFormatter.formatNumber(value, defaultLocale, NumberFormatStyle.Currency, digits, currency, currencyDisplay);
        }
        // Returns the number & currency without localization.
        return value + " " + currency;
    };
    L10nCurrencyPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'l10nCurrency',
                    pure: true
                },] },
    ];
    /** @nocollapse */
    L10nCurrencyPipe.ctorParameters = function () { return []; };
    return L10nCurrencyPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Breadth First Search (BFS) algorithm for traversing & searching tree data structure of DOM
 * explores the neighbor nodes first, before moving to the next level neighbors.
 * Time complexity: between O(1) and O(|V|^2).
 */
var BFS = (function () {
    function BFS() {
    }
    /**
     * Target node is a non empty text node.
     * @param {?} rootNode
     * @return {?}
     */
    BFS.getTargetNode = /**
     * Target node is a non empty text node.
     * @param {?} rootNode
     * @return {?}
     */
    function (rootNode) {
        return BFS.walk(rootNode);
    };
    /**
     * @param {?} rootNode
     * @return {?}
     */
    BFS.walk = /**
     * @param {?} rootNode
     * @return {?}
     */
    function (rootNode) {
        var /** @type {?} */ queue = [];
        var /** @type {?} */ iNode;
        var /** @type {?} */ depth = 0;
        var /** @type {?} */ nodeToDepthIncrease = 1;
        queue.push(rootNode);
        while (queue.length > 0 && depth <= this.MAX_DEPTH) {
            iNode = queue.shift();
            if (this.isTargetNode(iNode)) {
                return iNode;
            }
            if (depth < this.MAX_DEPTH && iNode.childNodes != null) {
                for (var _i = 0, _a = iNode.childNodes; _i < _a.length; _i++) {
                    var child = _a[_i];
                    if (this.isValidNode(child)) {
                        queue.push(child);
                    }
                }
            }
            if (--nodeToDepthIncrease == 0) {
                depth++;
                nodeToDepthIncrease = queue.length;
            }
        }
        return rootNode;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    BFS.isTargetNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return typeof node !== "undefined" &&
            node.nodeType == 3 &&
            node.nodeValue != null &&
            node.nodeValue.trim() != "";
    };
    /**
     * A valid node is not marked for translation.
     * @param {?} node
     * @return {?}
     */
    BFS.isValidNode = /**
     * A valid node is not marked for translation.
     * @param {?} node
     * @return {?}
     */
    function (node) {
        if (typeof node !== "undefined" && node.nodeType == 1 && node.attributes) {
            for (var _i = 0, _a = node.attributes; _i < _a.length; _i++) {
                var attr = _a[_i];
                if (attr && this.SELECTOR.test(attr.name))
                    return false;
            }
        }
        return true;
    };
    BFS.SELECTOR = new RegExp("^l10n|translate|locale");
    BFS.MAX_DEPTH = 10;
    return BFS;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @abstract
 */
var BaseDirective = (function () {
    function BaseDirective(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.attributes = [];
        this.subscriptions = [];
        this.TEXT_MUTATION_CONFIG = { subtree: true, characterData: true };
        this.SELECTOR = /^l10n-/;
    }
    /**
     * @return {?}
     */
    BaseDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this.el && this.el.nativeElement) {
            this.element = this.el.nativeElement;
            this.renderNode = BFS.getTargetNode(this.element);
            this.getKey();
            this.getAttributes();
            this.addTextListener();
            this.setup();
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    BaseDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (!!this.key) {
            if (this.nodeValue == null || this.nodeValue == "") {
                if (!!this.valueAttribute) {
                    this.key = this.valueAttribute;
                }
                else if (!!this.innerHTMLProperty) {
                    this.key = this.innerHTMLProperty;
                }
            }
            this.replaceText();
        }
        if (this.attributes.length > 0) {
            this.replaceAttributes();
        }
    };
    /**
     * @return {?}
     */
    BaseDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.removeTextListener();
        this.cancelSubscriptions();
    };
    /**
     * @return {?}
     */
    BaseDirective.prototype.getAttributesData = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ keys = this.getAttributesKeys();
        var /** @type {?} */ data = {};
        for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            data[key] = this.getValues(key);
        }
        return data;
    };
    /**
     * @return {?}
     */
    BaseDirective.prototype.getAttributesKeys = /**
     * @return {?}
     */
    function () {
        return this.attributes.map(function (attr) { return attr.key; });
    };
    /**
     * @param {?} value
     * @return {?}
     */
    BaseDirective.prototype.setText = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!!value) {
            if (!!this.nodeValue && !!this.key) {
                this.removeTextListener();
                this.renderer.setValue(this.renderNode, this.nodeValue.replace(this.key, value));
                this.addTextListener();
            }
            else if (!!this.valueAttribute) {
                this.renderer.setAttribute(this.element, "value", value);
            }
            else if (!!this.innerHTMLProperty) {
                this.renderer.setProperty(this.element, "innerHTML", value);
            }
        }
    };
    /**
     * @param {?} data
     * @return {?}
     */
    BaseDirective.prototype.setAttributes = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        for (var _i = 0, _a = this.attributes; _i < _a.length; _i++) {
            var attr = _a[_i];
            this.renderer.setAttribute(this.element, attr.name, data[attr.key]);
        }
    };
    /**
     * @return {?}
     */
    BaseDirective.prototype.addTextListener = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (typeof MutationObserver !== "undefined") {
            this.textObserver = new MutationObserver(function (mutations) {
                _this.renderNode = BFS.getTargetNode(_this.element);
                _this.getKey();
                _this.replaceText();
            });
            this.textObserver.observe(this.renderNode, this.TEXT_MUTATION_CONFIG);
        }
    };
    /**
     * @return {?}
     */
    BaseDirective.prototype.removeTextListener = /**
     * @return {?}
     */
    function () {
        if (typeof this.textObserver !== "undefined") {
            this.textObserver.disconnect();
        }
    };
    /**
     * @return {?}
     */
    BaseDirective.prototype.getText = /**
     * @return {?}
     */
    function () {
        this.nodeValue = this.renderNode != null ? /** @type {?} */ (this.renderNode.nodeValue) : "";
        return !!this.nodeValue ? this.nodeValue.trim() : "";
    };
    /**
     * @return {?}
     */
    BaseDirective.prototype.getKey = /**
     * @return {?}
     */
    function () {
        if (this.element.childNodes.length > 0) {
            this.key = this.getText();
        }
        else if (!!this.valueAttribute) {
            this.key = this.valueAttribute;
        }
        else if (!!this.innerHTMLProperty) {
            this.key = this.innerHTMLProperty;
        }
    };
    /**
     * @return {?}
     */
    BaseDirective.prototype.getAttributes = /**
     * @return {?}
     */
    function () {
        if (this.element.attributes) {
            for (var _i = 0, _a = this.element.attributes; _i < _a.length; _i++) {
                var attr = _a[_i];
                if (attr && this.SELECTOR.test(attr.name)) {
                    var /** @type {?} */ name_1 = attr.name.substr(5);
                    for (var _b = 0, _c = this.element.attributes; _b < _c.length; _b++) {
                        var targetAttr = _c[_b];
                        if (new RegExp("^" + name_1 + "$").test(targetAttr.name)) {
                            this.attributes.push({ name: name_1, key: targetAttr.value });
                        }
                    }
                }
            }
        }
    };
    /**
     * @return {?}
     */
    BaseDirective.prototype.cancelSubscriptions = /**
     * @return {?}
     */
    function () {
        this.subscriptions.forEach(function (subscription) {
            if (typeof subscription !== "undefined") {
                subscription.unsubscribe();
            }
        });
    };
    BaseDirective.propDecorators = {
        "valueAttribute": [{ type: Input, args: ['value',] },],
        "innerHTMLProperty": [{ type: Input, args: ['innerHTML',] },],
    };
    return BaseDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TranslateDirective = (function (_super) {
    __extends(TranslateDirective, _super);
    function TranslateDirective(translation, el, renderer) {
        var _this = _super.call(this, el, renderer) || this;
        _this.translation = translation;
        _this.el = el;
        _this.renderer = renderer;
        return _this;
    }
    Object.defineProperty(TranslateDirective.prototype, "l10nTranslate", {
        set: /**
         * @param {?} params
         * @return {?}
         */
        function (params) {
            this.params = params;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TranslateDirective.prototype, "translate", {
        set: /**
         * @param {?} params
         * @return {?}
         */
        function (params) {
            this.params = params;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TranslateDirective.prototype.setup = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.replace();
        this.subscriptions.push(this.translation.translationChanged().subscribe(function () { _this.replace(); }));
    };
    /**
     * @return {?}
     */
    TranslateDirective.prototype.replace = /**
     * @return {?}
     */
    function () {
        this.replaceText();
        this.replaceAttributes();
    };
    /**
     * @return {?}
     */
    TranslateDirective.prototype.replaceText = /**
     * @return {?}
     */
    function () {
        if (!!this.key) {
            this.setText(this.getValues(this.key));
        }
    };
    /**
     * @return {?}
     */
    TranslateDirective.prototype.replaceAttributes = /**
     * @return {?}
     */
    function () {
        if (this.attributes.length > 0) {
            var /** @type {?} */ keys = this.getAttributesKeys();
            this.setAttributes(this.getValues(keys));
        }
    };
    /**
     * @param {?} keys
     * @return {?}
     */
    TranslateDirective.prototype.getValues = /**
     * @param {?} keys
     * @return {?}
     */
    function (keys) {
        return this.translation.translate(keys, this.params);
    };
    TranslateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[l10nTranslate],[translate]'
                },] },
    ];
    /** @nocollapse */
    TranslateDirective.ctorParameters = function () { return [
        { type: TranslationService, },
        { type: ElementRef, },
        { type: Renderer2, },
    ]; };
    TranslateDirective.propDecorators = {
        "l10nTranslate": [{ type: Input },],
        "translate": [{ type: Input },],
        "params": [{ type: Input },],
    };
    return TranslateDirective;
}(BaseDirective));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var L10nDateDirective = (function (_super) {
    __extends(L10nDateDirective, _super);
    function L10nDateDirective(locale, el, renderer) {
        var _this = _super.call(this, el, renderer) || this;
        _this.locale = locale;
        _this.el = el;
        _this.renderer = renderer;
        _this.defaultFormat = 'mediumDate';
        _this.l10nDatePipe = new L10nDatePipe();
        return _this;
    }
    Object.defineProperty(L10nDateDirective.prototype, "l10nDate", {
        set: /**
         * @param {?} format
         * @return {?}
         */
        function (format) {
            this.format = format;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    L10nDateDirective.prototype.setup = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.replace();
        this.subscriptions.push(this.locale.defaultLocaleChanged.subscribe(function () { _this.replace(); }));
        this.subscriptions.push(this.locale.timezoneChanged.subscribe(function () { _this.replace(); }));
    };
    /**
     * @return {?}
     */
    L10nDateDirective.prototype.replace = /**
     * @return {?}
     */
    function () {
        this.replaceText();
        this.replaceAttributes();
    };
    /**
     * @return {?}
     */
    L10nDateDirective.prototype.replaceText = /**
     * @return {?}
     */
    function () {
        if (!!this.key) {
            this.setText(this.getValues(this.key));
        }
    };
    /**
     * @return {?}
     */
    L10nDateDirective.prototype.replaceAttributes = /**
     * @return {?}
     */
    function () {
        if (this.attributes.length > 0) {
            this.setAttributes(this.getAttributesData());
        }
    };
    /**
     * @param {?} keys
     * @return {?}
     */
    L10nDateDirective.prototype.getValues = /**
     * @param {?} keys
     * @return {?}
     */
    function (keys) {
        return this.l10nDatePipe.transform(keys, this.locale.getDefaultLocale(), this.format || this.defaultFormat, this.locale.getCurrentTimezone());
    };
    L10nDateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[l10nDate]'
                },] },
    ];
    /** @nocollapse */
    L10nDateDirective.ctorParameters = function () { return [
        { type: LocaleService, },
        { type: ElementRef, },
        { type: Renderer2, },
    ]; };
    L10nDateDirective.propDecorators = {
        "l10nDate": [{ type: Input },],
        "format": [{ type: Input },],
    };
    return L10nDateDirective;
}(BaseDirective));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var L10nDecimalDirective = (function (_super) {
    __extends(L10nDecimalDirective, _super);
    function L10nDecimalDirective(locale, el, renderer) {
        var _this = _super.call(this, el, renderer) || this;
        _this.locale = locale;
        _this.el = el;
        _this.renderer = renderer;
        _this.l10nDecimalPipe = new L10nDecimalPipe();
        return _this;
    }
    Object.defineProperty(L10nDecimalDirective.prototype, "l10nDecimal", {
        set: /**
         * @param {?} digits
         * @return {?}
         */
        function (digits) {
            this.digits = digits;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    L10nDecimalDirective.prototype.setup = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.replace();
        this.subscriptions.push(this.locale.defaultLocaleChanged.subscribe(function () { _this.replace(); }));
    };
    /**
     * @return {?}
     */
    L10nDecimalDirective.prototype.replace = /**
     * @return {?}
     */
    function () {
        this.replaceText();
        this.replaceAttributes();
    };
    /**
     * @return {?}
     */
    L10nDecimalDirective.prototype.replaceText = /**
     * @return {?}
     */
    function () {
        if (!!this.key) {
            this.setText(this.getValues(this.key));
        }
    };
    /**
     * @return {?}
     */
    L10nDecimalDirective.prototype.replaceAttributes = /**
     * @return {?}
     */
    function () {
        if (this.attributes.length > 0) {
            this.setAttributes(this.getAttributesData());
        }
    };
    /**
     * @param {?} keys
     * @return {?}
     */
    L10nDecimalDirective.prototype.getValues = /**
     * @param {?} keys
     * @return {?}
     */
    function (keys) {
        return this.l10nDecimalPipe.transform(keys, this.locale.getDefaultLocale(), this.digits);
    };
    L10nDecimalDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[l10nDecimal]'
                },] },
    ];
    /** @nocollapse */
    L10nDecimalDirective.ctorParameters = function () { return [
        { type: LocaleService, },
        { type: ElementRef, },
        { type: Renderer2, },
    ]; };
    L10nDecimalDirective.propDecorators = {
        "l10nDecimal": [{ type: Input },],
        "digits": [{ type: Input },],
    };
    return L10nDecimalDirective;
}(BaseDirective));
var L10nPercentDirective = (function (_super) {
    __extends(L10nPercentDirective, _super);
    function L10nPercentDirective(locale, el, renderer) {
        var _this = _super.call(this, el, renderer) || this;
        _this.locale = locale;
        _this.el = el;
        _this.renderer = renderer;
        _this.l10nPercentPipe = new L10nPercentPipe();
        return _this;
    }
    Object.defineProperty(L10nPercentDirective.prototype, "l10nPercent", {
        set: /**
         * @param {?} digits
         * @return {?}
         */
        function (digits) {
            this.digits = digits;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    L10nPercentDirective.prototype.setup = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.replace();
        this.subscriptions.push(this.locale.defaultLocaleChanged.subscribe(function () { _this.replace(); }));
    };
    /**
     * @return {?}
     */
    L10nPercentDirective.prototype.replace = /**
     * @return {?}
     */
    function () {
        this.replaceText();
        this.replaceAttributes();
    };
    /**
     * @return {?}
     */
    L10nPercentDirective.prototype.replaceText = /**
     * @return {?}
     */
    function () {
        if (!!this.key) {
            this.setText(this.getValues(this.key));
        }
    };
    /**
     * @return {?}
     */
    L10nPercentDirective.prototype.replaceAttributes = /**
     * @return {?}
     */
    function () {
        if (this.attributes.length > 0) {
            this.setAttributes(this.getAttributesData());
        }
    };
    /**
     * @param {?} keys
     * @return {?}
     */
    L10nPercentDirective.prototype.getValues = /**
     * @param {?} keys
     * @return {?}
     */
    function (keys) {
        return this.l10nPercentPipe.transform(keys, this.locale.getDefaultLocale(), this.digits);
    };
    L10nPercentDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[l10nPercent]'
                },] },
    ];
    /** @nocollapse */
    L10nPercentDirective.ctorParameters = function () { return [
        { type: LocaleService, },
        { type: ElementRef, },
        { type: Renderer2, },
    ]; };
    L10nPercentDirective.propDecorators = {
        "l10nPercent": [{ type: Input },],
        "digits": [{ type: Input },],
    };
    return L10nPercentDirective;
}(BaseDirective));
var L10nCurrencyDirective = (function (_super) {
    __extends(L10nCurrencyDirective, _super);
    function L10nCurrencyDirective(locale, el, renderer) {
        var _this = _super.call(this, el, renderer) || this;
        _this.locale = locale;
        _this.el = el;
        _this.renderer = renderer;
        _this.l10nCurrencyPipe = new L10nCurrencyPipe();
        return _this;
    }
    Object.defineProperty(L10nCurrencyDirective.prototype, "l10nCurrency", {
        set: /**
         * @param {?} digits
         * @return {?}
         */
        function (digits) {
            this.digits = digits;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    L10nCurrencyDirective.prototype.setup = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.replace();
        this.subscriptions.push(this.locale.defaultLocaleChanged.subscribe(function () { _this.replace(); }));
        this.subscriptions.push(this.locale.currencyCodeChanged.subscribe(function () { _this.replace(); }));
    };
    /**
     * @return {?}
     */
    L10nCurrencyDirective.prototype.replace = /**
     * @return {?}
     */
    function () {
        this.replaceText();
        this.replaceAttributes();
    };
    /**
     * @return {?}
     */
    L10nCurrencyDirective.prototype.replaceText = /**
     * @return {?}
     */
    function () {
        if (!!this.key) {
            this.setText(this.getValues(this.key));
        }
    };
    /**
     * @return {?}
     */
    L10nCurrencyDirective.prototype.replaceAttributes = /**
     * @return {?}
     */
    function () {
        if (this.attributes.length > 0) {
            this.setAttributes(this.getAttributesData());
        }
    };
    /**
     * @param {?} keys
     * @return {?}
     */
    L10nCurrencyDirective.prototype.getValues = /**
     * @param {?} keys
     * @return {?}
     */
    function (keys) {
        return this.l10nCurrencyPipe.transform(keys, this.locale.getDefaultLocale(), this.locale.getCurrentCurrency(), this.currencyDisplay, this.digits);
    };
    L10nCurrencyDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[l10nCurrency]'
                },] },
    ];
    /** @nocollapse */
    L10nCurrencyDirective.ctorParameters = function () { return [
        { type: LocaleService, },
        { type: ElementRef, },
        { type: Renderer2, },
    ]; };
    L10nCurrencyDirective.propDecorators = {
        "l10nCurrency": [{ type: Input },],
        "currencyDisplay": [{ type: Input },],
        "digits": [{ type: Input },],
    };
    return L10nCurrencyDirective;
}(BaseDirective));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Function that takes a control and returns either null when its valid, or an error object if its not.
 * @param {?} digits The format of the number
 * @param {?=} MIN_VALUE The minimum value for the number
 * @param {?=} MAX_VALUE The maximum value for the number
 * @return {?} An error object: 'format', 'minValue' or 'maxValue'; null in case the value is valid
 */
function l10nValidateNumber(digits, MIN_VALUE, MAX_VALUE) {
    if (MIN_VALUE === void 0) { MIN_VALUE = Number.MIN_VALUE; }
    if (MAX_VALUE === void 0) { MAX_VALUE = Number.MAX_VALUE; }
    var /** @type {?} */ locale = InjectorRef.get(LocaleService);
    var /** @type {?} */ localeValidation = InjectorRef.get(LocaleValidation);
    var /** @type {?} */ defaultLocale;
    var /** @type {?} */ NUMBER_REGEXP;
    return function (formControl) {
        if (formControl.value == null || formControl.value == "")
            return null;
        if (defaultLocale != locale.getDefaultLocale()) {
            NUMBER_REGEXP = localeValidation.getRegExp(digits);
            defaultLocale = locale.getDefaultLocale();
        }
        if (NUMBER_REGEXP.test(formControl.value)) {
            var /** @type {?} */ parsedValue = localeValidation.parseNumber(formControl.value);
            if (parsedValue != null && parsedValue < MIN_VALUE) {
                return {
                    minValue: {
                        valid: false
                    }
                };
            }
            else if (parsedValue != null && parsedValue > MAX_VALUE) {
                return {
                    maxValue: {
                        valid: false
                    }
                };
            }
            return null; // The number is valid.
        }
        else {
            return {
                format: {
                    valid: false
                }
            };
        }
    };
}
var L10nNumberValidatorDirective = (function () {
    function L10nNumberValidatorDirective() {
        this.MIN_VALUE = Number.MIN_VALUE;
        this.MAX_VALUE = Number.MAX_VALUE;
    }
    Object.defineProperty(L10nNumberValidatorDirective.prototype, "l10nValidateNumber", {
        set: /**
         * Format: {minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}.
         * @param {?} digits
         * @return {?}
         */
        function (digits) {
            this.digits = digits;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    L10nNumberValidatorDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.validator = l10nValidateNumber(this.digits, this.minValue || this.MIN_VALUE, this.maxValue || this.MAX_VALUE);
    };
    /**
     * @param {?} formControl
     * @return {?}
     */
    L10nNumberValidatorDirective.prototype.validate = /**
     * @param {?} formControl
     * @return {?}
     */
    function (formControl) {
        return this.validator(formControl);
    };
    L10nNumberValidatorDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[l10nValidateNumber][ngModel],[l10nValidateNumber][formControl]',
                    providers: [
                        { provide: NG_VALIDATORS, useExisting: forwardRef(function () { return L10nNumberValidatorDirective; }), multi: true }
                    ]
                },] },
    ];
    /** @nocollapse */
    L10nNumberValidatorDirective.ctorParameters = function () { return []; };
    L10nNumberValidatorDirective.propDecorators = {
        "l10nValidateNumber": [{ type: Input },],
        "digits": [{ type: Input },],
        "minValue": [{ type: Input },],
        "maxValue": [{ type: Input },],
    };
    return L10nNumberValidatorDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Provides dependencies, pipes & directives for translating messages.
 */
var TranslationModule = (function () {
    function TranslationModule(injector) {
        // Creates the instance of the InjectorRef, so that module dependencies are available.
        this.injector = injector;
    }
    /**
     * Use in AppModule: new instances of LocaleService & TranslationService.
     * @param {?} l10nConfig
     * @param {?=} token
     * @return {?}
     */
    TranslationModule.forRoot = /**
     * Use in AppModule: new instances of LocaleService & TranslationService.
     * @param {?} l10nConfig
     * @param {?=} token
     * @return {?}
     */
    function (l10nConfig, token) {
        if (token === void 0) { token = {}; }
        return {
            ngModule: TranslationModule,
            providers: [
                InjectorRef,
                { provide: LOCALE_CONFIG, useValue: l10nConfig.locale || {} },
                { provide: TRANSLATION_CONFIG, useValue: l10nConfig.translation || {} },
                LocaleService,
                {
                    provide: LocaleStorage,
                    useClass: token.localeStorage || BrowserStorage
                },
                TranslationService,
                {
                    provide: TranslationProvider,
                    useClass: token.translationProvider || HttpTranslationProvider
                },
                {
                    provide: TranslationHandler,
                    useClass: token.translationHandler || DefaultTranslationHandler
                },
                L10nLoader
            ]
        };
    };
    /**
     * Use in feature modules with lazy loading: new instance of TranslationService.
     * @param {?} l10nConfig
     * @param {?=} token
     * @return {?}
     */
    TranslationModule.forChild = /**
     * Use in feature modules with lazy loading: new instance of TranslationService.
     * @param {?} l10nConfig
     * @param {?=} token
     * @return {?}
     */
    function (l10nConfig, token) {
        if (token === void 0) { token = {}; }
        return {
            ngModule: TranslationModule,
            providers: [
                InjectorRef,
                { provide: TRANSLATION_CONFIG, useValue: l10nConfig.translation || {} },
                TranslationService,
                L10nLoader
            ]
        };
    };
    TranslationModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        TranslatePipe,
                        TranslateDirective
                    ],
                    exports: [
                        TranslatePipe,
                        TranslateDirective
                    ]
                },] },
    ];
    /** @nocollapse */
    TranslationModule.ctorParameters = function () { return [
        { type: InjectorRef, },
    ]; };
    return TranslationModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Provides dependencies, pipes & directives for translating messages, dates & numbers.
 */
var LocalizationModule = (function () {
    function LocalizationModule(injector) {
        // Creates the instance of the InjectorRef, so that module dependencies are available.
        this.injector = injector;
    }
    /**
     * Use in AppModule: new instances of LocaleService & TranslationService.
     * @param {?} l10nConfig
     * @param {?=} token
     * @return {?}
     */
    LocalizationModule.forRoot = /**
     * Use in AppModule: new instances of LocaleService & TranslationService.
     * @param {?} l10nConfig
     * @param {?=} token
     * @return {?}
     */
    function (l10nConfig, token) {
        if (token === void 0) { token = {}; }
        return {
            ngModule: LocalizationModule,
            providers: [
                InjectorRef,
                { provide: LOCALE_CONFIG, useValue: l10nConfig.locale || {} },
                { provide: TRANSLATION_CONFIG, useValue: l10nConfig.translation || {} },
                LocaleService,
                {
                    provide: LocaleStorage,
                    useClass: token.localeStorage || BrowserStorage
                },
                TranslationService,
                {
                    provide: TranslationProvider,
                    useClass: token.translationProvider || HttpTranslationProvider
                },
                {
                    provide: TranslationHandler,
                    useClass: token.translationHandler || DefaultTranslationHandler
                },
                L10nLoader
            ]
        };
    };
    /**
     * Use in feature modules with lazy loading: new instance of TranslationService.
     * @param {?} l10nConfig
     * @param {?=} token
     * @return {?}
     */
    LocalizationModule.forChild = /**
     * Use in feature modules with lazy loading: new instance of TranslationService.
     * @param {?} l10nConfig
     * @param {?=} token
     * @return {?}
     */
    function (l10nConfig, token) {
        if (token === void 0) { token = {}; }
        return {
            ngModule: LocalizationModule,
            providers: [
                InjectorRef,
                { provide: TRANSLATION_CONFIG, useValue: l10nConfig.translation || {} },
                TranslationService,
                L10nLoader
            ]
        };
    };
    LocalizationModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        L10nDatePipe,
                        L10nDecimalPipe,
                        L10nPercentPipe,
                        L10nCurrencyPipe,
                        L10nDateDirective,
                        L10nDecimalDirective,
                        L10nPercentDirective,
                        L10nCurrencyDirective
                    ],
                    imports: [
                        TranslationModule
                    ],
                    exports: [
                        TranslationModule,
                        L10nDatePipe,
                        L10nDecimalPipe,
                        L10nPercentPipe,
                        L10nCurrencyPipe,
                        L10nDateDirective,
                        L10nDecimalDirective,
                        L10nPercentDirective,
                        L10nCurrencyDirective
                    ]
                },] },
    ];
    /** @nocollapse */
    LocalizationModule.ctorParameters = function () { return [
        { type: InjectorRef, },
    ]; };
    return LocalizationModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Provides dependencies & directives for locale validation.
 */
var LocaleValidationModule = (function () {
    function LocaleValidationModule() {
    }
    /**
     * Use in AppModule: new instance of LocaleValidation.
     * @return {?}
     */
    LocaleValidationModule.forRoot = /**
     * Use in AppModule: new instance of LocaleValidation.
     * @return {?}
     */
    function () {
        return {
            ngModule: LocaleValidationModule,
            providers: [LocaleValidation]
        };
    };
    LocaleValidationModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        L10nNumberValidatorDirective
                    ],
                    exports: [
                        L10nNumberValidatorDirective
                    ]
                },] },
    ];
    /** @nocollapse */
    LocaleValidationModule.ctorParameters = function () { return []; };
    return LocaleValidationModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Angular l10n
 * An Angular library to translate messages, dates and numbers
 * Copyright Roberto Simonetti
 * MIT license
 * https://github.com/robisim74/angular-l10n
 */
/**
 * Entry point for all public APIs of the package.
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { InjectorRef, StorageStrategy, ProviderType, ISOCode, LOCALE_CONFIG, TRANSLATION_CONFIG, L10nLoader, LocaleService, LocaleStorage, BrowserStorage, TranslationService, TranslationProvider, HttpTranslationProvider, TranslationHandler, DefaultTranslationHandler, Translation, Localization, LocaleValidation, Collator, IntlAPI, Language, DefaultLocale$1 as DefaultLocale, Currency, Timezone, TranslatePipe, L10nDatePipe, L10nDecimalPipe, L10nPercentPipe, L10nCurrencyPipe, BaseDirective, TranslateDirective, L10nDateDirective, L10nDecimalDirective, L10nPercentDirective, L10nCurrencyDirective, L10nNumberValidatorDirective, l10nValidateNumber, TranslationModule, LocalizationModule, LocaleValidationModule };
//# sourceMappingURL=angular-l10n.js.map
