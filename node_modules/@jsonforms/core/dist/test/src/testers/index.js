"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
  The MIT License

  Copyright (c) 2018 EclipseSource Munich
  https://github.com/eclipsesource/jsonforms

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/
const isEmpty_1 = __importDefault(require("lodash/isEmpty"));
const get_1 = __importDefault(require("lodash/get"));
const endsWith_1 = __importDefault(require("lodash/endsWith"));
const last_1 = __importDefault(require("lodash/last"));
const isArray_1 = __importDefault(require("lodash/isArray"));
const reduce_1 = __importDefault(require("lodash/reduce"));
const toPairs_1 = __importDefault(require("lodash/toPairs"));
const has_1 = __importDefault(require("lodash/has"));
const includes_1 = __importDefault(require("lodash/includes"));
const resolvers_1 = require("../util/resolvers");
/**
 * Constant that indicates that a tester is not capable of handling
 * a combination of schema/data.
 * @type {number}
 */
exports.NOT_APPLICABLE = -1;
exports.isControl = (uischema) => !isEmpty_1.default(uischema) &&
    uischema.scope !== undefined &&
    uischema.scope !== undefined;
/**
 * Only applicable for Controls.
 *
 * This function checks whether the given UI schema is of type Control
 * and if so, resolves the sub-schema referenced by the control and applies
 * the given predicate
 *
 * @param {(JsonSchema) => boolean} predicate the predicate that should be
 *        applied to the resolved sub-schema
 */
exports.schemaMatches = (predicate) => (uischema, schema) => {
    if (isEmpty_1.default(uischema) || !exports.isControl(uischema)) {
        return false;
    }
    const schemaPath = uischema.scope;
    if (isEmpty_1.default(schemaPath)) {
        return false;
    }
    let currentDataSchema = resolvers_1.resolveSchema(schema, schemaPath);
    while (!isEmpty_1.default(currentDataSchema) && !isEmpty_1.default(currentDataSchema.$ref)) {
        currentDataSchema = resolvers_1.resolveSchema(schema, currentDataSchema.$ref);
    }
    if (currentDataSchema === undefined) {
        return false;
    }
    return predicate(currentDataSchema);
};
exports.schemaSubPathMatches = (subPath, predicate) => (uischema, schema) => {
    if (isEmpty_1.default(uischema) || !exports.isControl(uischema)) {
        return false;
    }
    const schemaPath = uischema.scope;
    if (isEmpty_1.default(schemaPath)) {
        return false;
    }
    let currentDataSchema = resolvers_1.resolveSchema(schema, `${schemaPath}`);
    while (!isEmpty_1.default(currentDataSchema.$ref)) {
        currentDataSchema = resolvers_1.resolveSchema(schema, currentDataSchema.$ref);
    }
    currentDataSchema = get_1.default(currentDataSchema, subPath);
    if (currentDataSchema === undefined) {
        return false;
    }
    return predicate(currentDataSchema);
};
/**
 * Only applicable for Controls.
 *
 * This function checks whether the given UI schema is of type Control
 * and if so, resolves the sub-schema referenced by the control and checks
 * whether the type of the sub-schema matches the expected one.
 *
 * @param {string} expectedType the expected type of the resolved sub-schema
 */
exports.schemaTypeIs = (expectedType) => exports.schemaMatches(schema => !isEmpty_1.default(schema) && schema.type === expectedType);
/**
 * Only applicable for Controls.
 *
 * This function checks whether the given UI schema is of type Control
 * and if so, resolves the sub-schema referenced by the control and checks
 * whether the format of the sub-schema matches the expected one.
 *
 * @param {string} expectedFormat the expected format of the resolved sub-schema
 */
exports.formatIs = (expectedFormat) => exports.schemaMatches(schema => !isEmpty_1.default(schema) &&
    schema.format === expectedFormat &&
    schema.type === 'string');
/**
 * Checks whether the given UI schema has the expected type.
 *
 * @param {string} expected the expected UI schema type
 */
exports.uiTypeIs = (expected) => (uischema) => !isEmpty_1.default(uischema) && uischema.type === expected;
/**
 * Checks whether the given UI schema has an option with the given
 * name and whether it has the expected value. If no options property
 * is set, returns false.
 *
 * @param {string} optionName the name of the option to check
 * @param {any} optionValue the expected value of the option
 */
exports.optionIs = (optionName, optionValue) => (uischema) => {
    const options = uischema.options;
    return !isEmpty_1.default(options) && options[optionName] === optionValue;
};
/**
 * Only applicable for Controls.
 *
 * Checks whether the scope of a control ends with the expected string.
 *
 * @param {string} expected the expected ending of the reference
 */
exports.scopeEndsWith = (expected) => (uischema) => {
    if (isEmpty_1.default(expected) || !exports.isControl(uischema)) {
        return false;
    }
    return endsWith_1.default(uischema.scope, expected);
};
/**
 * Only applicable for Controls.
 *
 * Checks whether the last segment of the scope matches the expected string.
 *
 * @param {string} expected the expected ending of the reference
 */
exports.scopeEndIs = (expected) => (uischema) => {
    if (isEmpty_1.default(expected) || !exports.isControl(uischema)) {
        return false;
    }
    const schemaPath = uischema.scope;
    return !isEmpty_1.default(schemaPath) && last_1.default(schemaPath.split('/')) === expected;
};
/**
 * A tester that allow composing other testers by && them.
 *
 * @param {Array<Tester>} testers the testers to be composed
 */
exports.and = (...testers) => (uischema, schema) => testers.reduce((acc, tester) => acc && tester(uischema, schema), true);
/**
 * A tester that allow composing other testers by || them.
 *
 * @param {Array<Tester>} testers the testers to be composed
 */
exports.or = (...testers) => (uischema, schema) => testers.reduce((acc, tester) => acc || tester(uischema, schema), false);
/**
 * Create a ranked tester that will associate a number with a given tester, if the
 * latter returns true.
 *
 * @param {number} rank the rank to be returned in case the tester returns true
 * @param {Tester} tester a tester
 */
exports.rankWith = (rank, tester) => (uischema, schema) => {
    if (tester(uischema, schema)) {
        return rank;
    }
    return exports.NOT_APPLICABLE;
};
exports.withIncreasedRank = (by, rankedTester) => (uischema, schema) => {
    const rank = rankedTester(uischema, schema);
    if (rank === exports.NOT_APPLICABLE) {
        return exports.NOT_APPLICABLE;
    }
    return rank + by;
};
/**
 * Default tester for boolean.
 * @type {RankedTester}
 */
exports.isBooleanControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('boolean'));
// TODO: rather check for properties property
exports.isObjectControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('object'));
exports.isAllOfControl = exports.and(exports.uiTypeIs('Control'), exports.schemaMatches(schema => schema.hasOwnProperty('allOf')));
exports.isAnyOfControl = exports.and(exports.uiTypeIs('Control'), exports.schemaMatches(schema => schema.hasOwnProperty('anyOf')));
exports.isOneOfControl = exports.and(exports.uiTypeIs('Control'), exports.schemaMatches(schema => schema.hasOwnProperty('oneOf')));
/**
 * Tests whether the given UI schema is of type Control and if the schema
 * has a 'date' format.
 * @type {Tester}
 */
exports.isDateControl = exports.and(exports.uiTypeIs('Control'), exports.formatIs('date'));
/**
 * Tests whether the given UI schema is of type Control and if the schema
 * has an enum.
 * @type {Tester}
 */
exports.isEnumControl = exports.and(exports.uiTypeIs('Control'), exports.schemaMatches(schema => schema.hasOwnProperty('enum')));
/**
 * Tests whether the given UI schema is of type Control and if the schema
 * is of type integer
 * @type {Tester}
 */
exports.isIntegerControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('integer'));
/**
 * Tests whether the given UI schema is of type Control and if the schema
 * is of type number
 * @type {Tester}
 */
exports.isNumberControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('number'));
/**
 * Tests whether the given UI schema is of type Control and if the schema
 * is of type string
 * @type {Tester}
 */
exports.isStringControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('string'));
/**
 * Tests whether the given UI schema is of type Control and if is has
 * a 'multi' option.
 * @type {Tester}
 */
exports.isMultiLineControl = exports.and(exports.uiTypeIs('Control'), exports.optionIs('multi', true));
/**
 * Tests whether the given UI schema is of type Control and if the schema
 * has a 'time' format.
 * @type {Tester}
 */
exports.isTimeControl = exports.and(exports.uiTypeIs('Control'), exports.formatIs('time'));
/**
 * Tests whether the given UI schema is of type Control and if the schema
 * has a 'date-time' format.
 * @type {Tester}
 */
exports.isDateTimeControl = exports.and(exports.uiTypeIs('Control'), exports.formatIs('date-time'));
/**
 * Tests whether the given UI schema is of type Control and if the schema
 * is an array of objects.
 * @type {Tester}
 */
exports.isObjectArrayControl = exports.and(exports.uiTypeIs('Control'), exports.schemaMatches(schema => !isEmpty_1.default(schema) &&
    schema.type === 'array' &&
    !isEmpty_1.default(schema.items) &&
    !Array.isArray(schema.items) // we don't care about tuples
), exports.schemaSubPathMatches('items', schema => schema.type === 'object'));
const traverse = (any, pred) => {
    if (isArray_1.default(any)) {
        return reduce_1.default(any, (acc, el) => acc || traverse(el, pred), false);
    }
    if (pred(any)) {
        return true;
    }
    if (any.items) {
        return traverse(any.items, pred);
    }
    if (any.properties) {
        return reduce_1.default(toPairs_1.default(any.properties), (acc, [_key, val]) => acc || traverse(val, pred), false);
    }
    return false;
};
exports.isObjectArrayWithNesting = (uischema, schema) => {
    if (!exports.uiTypeIs('Control')(uischema, schema)) {
        return false;
    }
    const schemaPath = uischema.scope;
    const resolvedSchema = resolvers_1.resolveSchema(schema, schemaPath);
    const wantedNestingByType = {
        object: 2,
        array: 1
    };
    if (has_1.default(resolvedSchema, 'items')) {
        // check if nested arrays
        if (traverse(resolvedSchema.items, val => {
            if (val === schema) {
                return false;
            }
            // we don't support multiple types
            if (typeof val.type !== 'string') {
                return true;
            }
            const typeCount = wantedNestingByType[val.type];
            if (typeCount === undefined) {
                return false;
            }
            wantedNestingByType[val.type] = typeCount - 1;
            if (wantedNestingByType[val.type] === 0) {
                return true;
            }
            return false;
        })) {
            return true;
        }
        // check if uischema options detail is set
        if (uischema.options && uischema.options.detail) {
            if (typeof uischema.options.detail === 'string') {
                return uischema.options.detail.toUpperCase() !== 'DEFAULT';
            }
            else if (typeof uischema.options.detail === 'object' &&
                uischema.options.detail.type) {
                return true;
            }
        }
    }
    return false;
};
/**
 * Synonym for isObjectArrayControl
 */
exports.isArrayObjectControl = exports.isObjectArrayControl;
/**
 * Tests whether the given UI schema is of type Control and if the schema
 * is an array of a primitive type.
 * @type {Tester}
 */
exports.isPrimitiveArrayControl = exports.and(exports.uiTypeIs('Control'), exports.schemaMatches(schema => !isEmpty_1.default(schema) &&
    schema.type === 'array' &&
    !isEmpty_1.default(schema.items) &&
    !Array.isArray(schema.items) // we don't care about tuples
), exports.schemaSubPathMatches('items', schema => includes_1.default(['integer', 'number', 'boolean', 'string'], schema.type)));
/**
 * Tests whether a given UI schema is of type Control,
 * if the schema is of type number or integer and
 * whether the schema defines a numerical range with a default value.
 * @type {Tester}
 */
exports.isRangeControl = exports.and(exports.uiTypeIs('Control'), exports.or(exports.schemaTypeIs('number'), exports.schemaTypeIs('integer')), exports.schemaMatches(schema => schema.hasOwnProperty('maximum') &&
    schema.hasOwnProperty('minimum') &&
    schema.hasOwnProperty('default')), exports.optionIs('slider', true));
/**
 * Tests whether the given UI schema is of type Control, if the schema
 * is of type string and has option format
 * @type {Tester}
 */
exports.isNumberFormatControl = exports.and(exports.uiTypeIs('Control'), exports.schemaTypeIs('integer'), exports.optionIs('format', true));
exports.isCategorization = (category) => category.type === 'Categorization';
exports.isCategory = (uischema) => uischema.type === 'Category';
exports.hasCategory = (categorization) => {
    if (isEmpty_1.default(categorization.elements)) {
        return false;
    }
    // all children of the categorization have to be categories
    return categorization.elements
        .map(elem => exports.isCategorization(elem) ? exports.hasCategory(elem) : exports.isCategory(elem))
        .reduce((prev, curr) => prev && curr, true);
};
exports.categorizationHasCategory = (uischema) => exports.hasCategory(uischema);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdGVzdGVycy9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXVCRTtBQUNGLDZEQUFxQztBQUNyQyxxREFBNkI7QUFDN0IsK0RBQXVDO0FBQ3ZDLHVEQUErQjtBQUMvQiw2REFBcUM7QUFDckMsMkRBQW1DO0FBQ25DLDZEQUFxQztBQUNyQyxxREFBNkI7QUFDN0IsK0RBQXVDO0FBT3ZDLGlEQUFrRDtBQUVsRDs7OztHQUlHO0FBQ1UsUUFBQSxjQUFjLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFjcEIsUUFBQSxTQUFTLEdBQUcsQ0FBQyxRQUFhLEVBQThCLEVBQUUsQ0FDckUsQ0FBQyxpQkFBTyxDQUFDLFFBQVEsQ0FBQztJQUNsQixRQUFRLENBQUMsS0FBSyxLQUFLLFNBQVM7SUFDNUIsUUFBUSxDQUFDLEtBQUssS0FBSyxTQUFTLENBQUM7QUFFL0I7Ozs7Ozs7OztHQVNHO0FBQ1UsUUFBQSxhQUFhLEdBQUcsQ0FDM0IsU0FBMEMsRUFDbEMsRUFBRSxDQUFDLENBQUMsUUFBeUIsRUFBRSxNQUFrQixFQUFXLEVBQUU7SUFDdEUsSUFBSSxpQkFBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsaUJBQVMsQ0FBQyxRQUFRLENBQUMsRUFBRTtRQUM3QyxPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsTUFBTSxVQUFVLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQztJQUNsQyxJQUFJLGlCQUFPLENBQUMsVUFBVSxDQUFDLEVBQUU7UUFDdkIsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUNELElBQUksaUJBQWlCLEdBQWUseUJBQWEsQ0FBQyxNQUFNLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFDdEUsT0FBTyxDQUFDLGlCQUFPLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLGlCQUFPLENBQUMsaUJBQWlCLENBQUMs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